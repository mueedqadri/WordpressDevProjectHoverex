{"version":3,"sources":["webpack://wp/webpack/bootstrap","webpack://wp/./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/defineProperty.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/iterableToArray.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/slicedToArray.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/typeof.js","webpack://wp/./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js","webpack://wp/@wordpress/rich-text/src/apply-format.js","webpack://wp/@wordpress/rich-text/src/can-indent-list-items.js","webpack://wp/@wordpress/rich-text/src/can-outdent-list-items.js","webpack://wp/@wordpress/rich-text/src/change-list-type.js","webpack://wp/@wordpress/rich-text/src/component/format-edit.js","webpack://wp/@wordpress/rich-text/src/component/index.js","webpack://wp/@wordpress/rich-text/src/component/use-boundary-style.js","webpack://wp/@wordpress/rich-text/src/component/use-format-types.js","webpack://wp/@wordpress/rich-text/src/component/use-inline-warning.js","webpack://wp/@wordpress/rich-text/src/concat.js","webpack://wp/@wordpress/rich-text/src/create-element.js","webpack://wp/@wordpress/rich-text/src/create.js","webpack://wp/@wordpress/rich-text/src/get-active-format.js","webpack://wp/@wordpress/rich-text/src/get-active-formats.js","webpack://wp/@wordpress/rich-text/src/get-active-object.js","webpack://wp/@wordpress/rich-text/src/get-format-type.js","webpack://wp/@wordpress/rich-text/src/get-last-child-index.js","webpack://wp/@wordpress/rich-text/src/get-line-index.js","webpack://wp/@wordpress/rich-text/src/get-parent-line-index.js","webpack://wp/@wordpress/rich-text/src/get-text-content.js","webpack://wp/@wordpress/rich-text/src/indent-list-items.js","webpack://wp/@wordpress/rich-text/src/index.js","webpack://wp/@wordpress/rich-text/src/insert-line-separator.js","webpack://wp/@wordpress/rich-text/src/insert-object.js","webpack://wp/@wordpress/rich-text/src/insert.js","webpack://wp/@wordpress/rich-text/src/is-active-list-type.js","webpack://wp/@wordpress/rich-text/src/is-collapsed.js","webpack://wp/@wordpress/rich-text/src/is-empty.js","webpack://wp/@wordpress/rich-text/src/is-format-equal.js","webpack://wp/@wordpress/rich-text/src/is-list-root-selected.js","webpack://wp/@wordpress/rich-text/src/join.js","webpack://wp/@wordpress/rich-text/src/normalise-formats.js","webpack://wp/@wordpress/rich-text/src/outdent-list-items.js","webpack://wp/@wordpress/rich-text/src/register-format-type.js","webpack://wp/@wordpress/rich-text/src/remove-format.js","webpack://wp/@wordpress/rich-text/src/remove-line-separator.js","webpack://wp/@wordpress/rich-text/src/remove.js","webpack://wp/@wordpress/rich-text/src/replace.js","webpack://wp/@wordpress/rich-text/src/slice.js","webpack://wp/@wordpress/rich-text/src/special-characters.js","webpack://wp/@wordpress/rich-text/src/split.js","webpack://wp/@wordpress/rich-text/src/store/actions.js","webpack://wp/@wordpress/rich-text/src/store/index.js","webpack://wp/@wordpress/rich-text/src/store/reducer.js","webpack://wp/@wordpress/rich-text/src/store/selectors.js","webpack://wp/@wordpress/rich-text/src/to-dom.js","webpack://wp/@wordpress/rich-text/src/to-html-string.js","webpack://wp/@wordpress/rich-text/src/to-tree.js","webpack://wp/@wordpress/rich-text/src/toggle-format.js","webpack://wp/@wordpress/rich-text/src/unregister-format-type.js","webpack://wp/@wordpress/rich-text/src/update-formats.js","webpack://wp/./node_modules/rememo/es/rememo.js","webpack://wp/external {\"this\":[\"wp\",\"data\"]}","webpack://wp/external {\"this\":[\"wp\",\"deprecated\"]}","webpack://wp/external {\"this\":[\"wp\",\"element\"]}","webpack://wp/external {\"this\":[\"wp\",\"escapeHtml\"]}","webpack://wp/external {\"this\":[\"wp\",\"keycodes\"]}","webpack://wp/external {\"this\":\"lodash\"}"],"names":["replace","array","index","value","slice","applyFormat","format","startIndex","start","endIndex","end","formats","activeFormats","newFormats","startFormat","find","type","indexOf","position","Infinity","filter","length","splice","normaliseFormats","reject","canIndentListItems","lineIndex","getLineIndex","undefined","replacements","previousLineIndex","formatsAtLineIndex","formatsAtPreviousLineIndex","canOutdentListItems","startingLineIndex","changeListType","newFormat","text","startLineFormats","endLineFormats","getParentLineIndex","newReplacements","startCount","endCount","changed","LINE_SEPARATOR","map","i","interactiveContentTags","Set","FormatEdit","formatTypes","onChange","onFocus","allowedFormats","withoutInteractiveFormatting","name","Edit","edit","tagName","has","activeFormat","getActiveFormat","isActive","activeObject","getActiveObject","isObjectActive","attributes","INSERTION_INPUT_TYPES_TO_IGNORE","whiteSpace","defaultStyle","EMPTY_ACTIVE_FORMATS","createPrepareEditableTree","fns","reduce","accumulator","fn","fixPlaceholderSelection","defaultView","selection","getSelection","anchorNode","anchorOffset","nodeType","ELEMENT_NODE","targetNode","childNodes","getAttribute","collapseToStart","RichText","ref","TagName","selectionStart","selectionEnd","children","placeholder","disabled","preserveWhiteSpace","onPaste","onDelete","onEnter","onSelectionChange","unstableOnFocus","setFocusedElement","instanceId","clientId","identifier","multilineTag","__unstableMultilineTag","multilineRootTag","__unstableMultilineRootTag","disableFormats","__unstableDisableFormats","didAutomaticChange","__unstableDidAutomaticChange","inputRule","__unstableInputRule","markAutomaticChange","__unstableMarkAutomaticChange","allowPrefixTransformations","__unstableAllowPrefixTransformations","undo","__unstableUndo","isCaretWithinFormattedText","__unstableIsCaretWithinFormattedText","onEnterFormattedText","__unstableOnEnterFormattedText","onExitFormattedText","__unstableOnExitFormattedText","onCreateUndoLevel","__unstableOnCreateUndoLevel","isSelected","__unstableIsSelected","useState","setActiveFormats","useFormatTypes","prepareHandlers","valueHandlers","changeHandlers","dependencies","getDoc","current","ownerDocument","getWin","formatToValue","string","Array","prepare","result","create","html","multilineWrapperTags","removeEditorOnlyFormats","val","forEach","formatType","__experimentalCreatePrepareEditableTree","removeFormat","valueToFormat","toHTMLString","_value","useRef","record","useMemo","initialRecord","createRecord","range","rangeCount","getRangeAt","element","__unstableIsEditableTree","applyRecord","newRecord","domOnly","apply","prepareEditableTree","__unstableDomOnly","handlePaste","event","preventDefault","clipboardData","items","files","isNil","plainText","getData","error1","error2","window","console","log","handleChange","insert","transformed","accumlator","__unstablePasteRule","from","item","getAsFile","file","size","push","handleDelete","keyCode","DELETE","BACKSPACE","ESCAPE","currentValue","isReverse","remove","newValue","isEmptyLine","removeLineSeparator","isCollapsed","handleEnter","ENTER","shiftKey","handleSpace","altKey","metaKey","ctrlKey","SPACE","characterBefore","indentListItems","handleHorizontalNavigation","LEFT","RIGHT","currentActiveFormats","collapsed","getComputedStyle","direction","reverseKey","formatsBefore","formatsAfter","newActiveFormatsLength","source","newActiveFormats","newPos","handleKeyDown","defaultPrevented","lastHistoryValue","createUndoLevel","isComposing","timeout","handleInput","inputType","nativeEvent","oldActiveFormats","change","updateFormats","withoutHistory","clearTimeout","setTimeout","handleCompositionStart","removeEventListener","handleSelectionChange","handleCompositionEnd","addEventListener","didMount","activeElement","oldRecord","getActiveFormats","Object","values","changeHandler","handlePointerDown","target","textContent","parentNode","createRange","setStart","setEnd","removeAllRanges","addRange","rafId","handleFocus","requestAnimationFrame","deprecated","alternative","handleBlur","applyFromProps","useEffect","useLayoutEffect","cancelAnimationFrame","focus","editableProps","role","style","className","onInput","onCompositionStart","onCompositionEnd","onKeyDown","onBlur","onMouseDown","onTouchStart","onKeyUp","onMouseUp","onTouchEnd","contentEditable","suppressContentEditableWarning","useBoundaryStyle","useInlineWarning","editableTagName","forwardRef","boundarySelector","querySelector","computedStyle","newColor","color","selector","rule","globalStyleId","globalStyle","getElementById","createElement","id","head","appendChild","innerHTML","formatTypesSelector","select","getFormatTypes","useSelect","keyedSelected","__experimentalGetPropsForEditableTreePreparation","richTextIdentifier","blockClientId","dispatch","useDispatch","selected","handler","__experimentalCreateOnChangeEditableValue","key","dispatchers","__experimentalGetPropsForEditableTreeChangeHandler","process","display","warn","mergePair","a","b","concat","implementation","body","createHTMLDocument","createEmptyValue","simpleFindKey","object","toFormat","class","getFormatTypeForClassName","trim","getFormatTypeForBareElement","registeredAttributes","unregisteredAttributes","isEditableTree","document","createFromElement","createFromMultilineElement","accumulateSelection","node","startContainer","startOffset","endContainer","endOffset","currentLength","TEXT_NODE","filterRange","nodeValue","collapseWhiteSpace","ZWNBSPRegExp","RegExp","ZWNBSP","removePadding","currentWrapperTags","hasChildNodes","nodeName","toLowerCase","lastFormats","lastFormat","getAttributes","isFormatEqual","OBJECT_REPLACEMENT_CHARACTER","mergeFormats","hasAttributes","getFormatType","getLastChildIndex","lineFormats","childIndex","formatsAtIndex","startFormats","getTextContent","getTargetLevelLineIndex","rootFormat","targetLevelLineIndex","targetFormats","lastformat","insertLineSeparator","beforeText","previousLineSeparatorIndex","lastIndexOf","previousLineSeparatorFormats","valueToInsert","insertObject","formatToInsert","isActiveListType","rootType","replacement","isEmpty","format1","format2","attributes1","attributes2","keys1","keys","keys2","isListRootSelected","join","separator","formatsAtPreviousIndex","newFormatsAtIndex","formatIndex","previousFormat","outdentListItems","parentFormats","endingLineIndex","lastChildIndex","currentFormats","registerFormatType","settings","error","test","formatTypeForBareElement","formatTypeForClassName","title","keywords","addFormatTypes","filterFormats","backward","removeStart","removeEnd","pattern","match","rest","offset","newText","fill","split","splitAtSelection","arguments","nextStart","substring","before","after","castArray","removeFormatTypes","names","registerStore","reducer","selectors","actions","state","action","keyBy","omit","combineReducers","createSelector","bareElementTagName","elementClassName","createPathToNode","rootNode","path","previousSibling","getNodeByPath","shift","append","child","createTextNode","setAttribute","appendText","appendData","getLastChild","lastChild","getParent","isText","getText","removeChild","toDom","doc","startPath","endPath","createEmpty","tree","toTree","onStartIndex","pointer","onEndIndex","applyValue","applySelection","future","futureChild","firstChild","currentChild","isEqualNode","data","replaceChild","currentAttributes","futureAttributes","ii","removeAttribute","isRangeEqual","HTMLElement","createChildrenHTML","parent","createElementHTML","attributeString","isValidAttributeName","escapeAttribute","escapeEditableHTML","fromFormat","boundaryClass","elementAttributes","isEqualUntil","formatsLength","multilineFormat","deepestActiveFormat","lastSeparatorFormats","lastCharacterFormats","lastCharacter","character","charAt","shouldInsertPadding","characterFormats","newNode","contenteditable","toggleFormat","unregisterFormatType","oldFormat"],"mappings":"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;AACA;AACA;AACA,WAAW,MAAM;AACjB,WAAW,MAAM;AACjB,WAAW,OAAO;AAClB;AACA,YAAY,QAAQ;AACpB;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,cAAc;AACnC;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW,SAAS;AACpB,WAAW,SAAS;AACpB;AACA;AACA;AACA,YAAY,SAAS;AACrB;AACe;AACf;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,MAAM;AAClB;AACA,aAAa,OAAO;AACpB;AACA;AACA;AACA;AACA;;AAEA,cAAc,uBAAuB;AACrC;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB,YAAY,KAAK;AACjB;AACA,aAAa,EAAE;AACf;AACA;AACA;AACA;;AAEA;AACA;AACA,cAAc,SAAS;AACvB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,CAAC;;;;;;;;;;;;ACjRD,aAAa,qCAAqC,EAAE,I;;;;;;;;;;;ACApD,aAAa,2CAA2C,EAAE,I;;;;;;;;;;;ACA1D,aAAa,wCAAwC,EAAE,I;;;;;;;;;;;ACAvD,aAAa,2CAA2C,EAAE,I;;;;;;;;;;;ACA1D,aAAa,yCAAyC,EAAE,I;;;;;;;;;;;ACAxD,aAAa,iCAAiC,EAAE,I","file":"rich-text.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/@wordpress/rich-text/build-module/index.js\");\n","export default function _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}","export default function _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return arrayLikeToArray(arr);\n}","export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","export default function _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}","export default function _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}","export default function _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","export default function _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}","import arrayWithHoles from \"@babel/runtime/helpers/esm/arrayWithHoles\";\nimport iterableToArrayLimit from \"@babel/runtime/helpers/esm/iterableToArrayLimit\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableRest from \"@babel/runtime/helpers/esm/nonIterableRest\";\nexport default function _slicedToArray(arr, i) {\n  return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();\n}","import arrayWithoutHoles from \"@babel/runtime/helpers/esm/arrayWithoutHoles\";\nimport iterableToArray from \"@babel/runtime/helpers/esm/iterableToArray\";\nimport unsupportedIterableToArray from \"@babel/runtime/helpers/esm/unsupportedIterableToArray\";\nimport nonIterableSpread from \"@babel/runtime/helpers/esm/nonIterableSpread\";\nexport default function _toConsumableArray(arr) {\n  return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();\n}","export default function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}","import arrayLikeToArray from \"@babel/runtime/helpers/esm/arrayLikeToArray\";\nexport default function _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);\n}","/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\nfunction replace( array, index, value ) {\n\tarray = array.slice();\n\tarray[ index ] = value;\n\treturn array;\n}\n\n/**\n * Apply a format object to a Rich Text value from the given `startIndex` to the\n * given `endIndex`. Indices are retrieved from the selection if none are\n * provided.\n *\n * @param {RichTextValue}  value        Value to modify.\n * @param {RichTextFormat} format       Format to apply.\n * @param {number}         [startIndex] Start index.\n * @param {number}         [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function applyFormat(\n\tvalue,\n\tformat,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// The selection is collapsed.\n\tif ( startIndex === endIndex ) {\n\t\tconst startFormat = find( newFormats[ startIndex ], {\n\t\t\ttype: format.type,\n\t\t} );\n\n\t\t// If the caret is at a format of the same type, expand start and end to\n\t\t// the edges of the format. This is useful to apply new attributes.\n\t\tif ( startFormat ) {\n\t\t\tconst index = newFormats[ startIndex ].indexOf( startFormat );\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ startIndex ] &&\n\t\t\t\tnewFormats[ startIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ startIndex ] = replace(\n\t\t\t\t\tnewFormats[ startIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile (\n\t\t\t\tnewFormats[ endIndex ] &&\n\t\t\t\tnewFormats[ endIndex ][ index ] === startFormat\n\t\t\t) {\n\t\t\t\tnewFormats[ endIndex ] = replace(\n\t\t\t\t\tnewFormats[ endIndex ],\n\t\t\t\t\tindex,\n\t\t\t\t\tformat\n\t\t\t\t);\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// Determine the highest position the new format can be inserted at.\n\t\tlet position = +Infinity;\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tif ( newFormats[ index ] ) {\n\t\t\t\tnewFormats[ index ] = newFormats[ index ].filter(\n\t\t\t\t\t( { type } ) => type !== format.type\n\t\t\t\t);\n\n\t\t\t\tconst length = newFormats[ index ].length;\n\n\t\t\t\tif ( length < position ) {\n\t\t\t\t\tposition = length;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tnewFormats[ index ] = [];\n\t\t\t\tposition = 0;\n\t\t\t}\n\t\t}\n\n\t\tfor ( let index = startIndex; index < endIndex; index++ ) {\n\t\t\tnewFormats[ index ].splice( position, 0, format );\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\t// Always revise active formats. This serves as a placeholder for new\n\t\t// inputs with the format so new input appears with the format applied,\n\t\t// and ensures a format of the same type uses the latest values.\n\t\tactiveFormats: [\n\t\t\t...reject( activeFormats, { type: format.type } ),\n\t\t\tformat,\n\t\t],\n\t} );\n}\n","/**\n * Internal dependencies\n */\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Checks if the selected list item can be indented.\n *\n * @param {RichTextValue} value Value to check.\n *\n * @return {boolean} Whether or not the selected list item can be indented.\n */\nexport function canIndentListItems( value ) {\n\tconst lineIndex = getLineIndex( value );\n\n\t// There is only one line, so the line cannot be indented.\n\tif ( lineIndex === undefined ) {\n\t\treturn false;\n\t}\n\n\tconst { replacements } = value;\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst formatsAtLineIndex = replacements[ lineIndex ] || [];\n\tconst formatsAtPreviousLineIndex = replacements[ previousLineIndex ] || [];\n\n\t// If the indentation of the current line is greater than previous line,\n\t// then the line cannot be furter indented.\n\treturn formatsAtLineIndex.length <= formatsAtPreviousLineIndex.length;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Checks if the selected list item can be outdented.\n *\n * @param {RichTextValue} value Value to check.\n *\n * @return {boolean} Whether or not the selected list item can be outdented.\n */\nexport function canOutdentListItems( value ) {\n\tconst { replacements, start } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\treturn replacements[ startingLineIndex ] !== undefined;\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { getParentLineIndex } from './get-parent-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Changes the list type of the selected indented list, if any. Looks at the\n * currently selected list item and takes the parent list, then changes the list\n * type of this list. When multiple lines are selected, the parent lists are\n * takes and changed.\n *\n * @param {RichTextValue}  value     Value to change.\n * @param {RichTextFormat} newFormat The new list format object. Choose between\n *                                   `{ type: 'ol' }` and `{ type: 'ul' }`.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function changeListType( value, newFormat ) {\n\tconst { text, replacements, start, end } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\tconst startLineFormats = replacements[ startingLineIndex ] || [];\n\tconst endLineFormats = replacements[ getLineIndex( value, end ) ] || [];\n\tconst startIndex = getParentLineIndex( value, startingLineIndex );\n\tconst newReplacements = replacements.slice();\n\tconst startCount = startLineFormats.length - 1;\n\tconst endCount = endLineFormats.length - 1;\n\n\tlet changed;\n\n\tfor ( let index = startIndex + 1 || 0; index < text.length; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( ( newReplacements[ index ] || [] ).length <= startCount ) {\n\t\t\tbreak;\n\t\t}\n\n\t\tif ( ! newReplacements[ index ] ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tchanged = true;\n\t\tnewReplacements[ index ] = newReplacements[ index ].map(\n\t\t\t( format, i ) => {\n\t\t\t\treturn i < startCount || i > endCount ? format : newFormat;\n\t\t\t}\n\t\t);\n\t}\n\n\tif ( ! changed ) {\n\t\treturn value;\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newReplacements,\n\t};\n}\n","/**\n * Internal dependencies\n */\nimport { getActiveFormat } from '../get-active-format';\nimport { getActiveObject } from '../get-active-object';\n\n/**\n * Set of all interactive content tags.\n *\n * @see https://html.spec.whatwg.org/multipage/dom.html#interactive-content\n */\nconst interactiveContentTags = new Set( [\n\t'a',\n\t'audio',\n\t'button',\n\t'details',\n\t'embed',\n\t'iframe',\n\t'input',\n\t'label',\n\t'select',\n\t'textarea',\n\t'video',\n] );\n\nexport default function FormatEdit( {\n\tformatTypes,\n\tonChange,\n\tonFocus,\n\tvalue,\n\tallowedFormats,\n\twithoutInteractiveFormatting,\n} ) {\n\treturn formatTypes.map( ( { name, edit: Edit, tagName } ) => {\n\t\tif ( ! Edit ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif ( allowedFormats && allowedFormats.indexOf( name ) === -1 ) {\n\t\t\treturn null;\n\t\t}\n\n\t\tif (\n\t\t\twithoutInteractiveFormatting &&\n\t\t\tinteractiveContentTags.has( tagName )\n\t\t) {\n\t\t\treturn null;\n\t\t}\n\n\t\tconst activeFormat = getActiveFormat( value, name );\n\t\tconst isActive = activeFormat !== undefined;\n\t\tconst activeObject = getActiveObject( value );\n\t\tconst isObjectActive =\n\t\t\tactiveObject !== undefined && activeObject.type === name;\n\n\t\treturn (\n\t\t\t<Edit\n\t\t\t\tkey={ name }\n\t\t\t\tisActive={ isActive }\n\t\t\t\tactiveAttributes={\n\t\t\t\t\tisActive ? activeFormat.attributes || {} : {}\n\t\t\t\t}\n\t\t\t\tisObjectActive={ isObjectActive }\n\t\t\t\tactiveObjectAttributes={\n\t\t\t\t\tisObjectActive ? activeObject.attributes || {} : {}\n\t\t\t\t}\n\t\t\t\tvalue={ value }\n\t\t\t\tonChange={ onChange }\n\t\t\t\tonFocus={ onFocus }\n\t\t\t/>\n\t\t);\n\t} );\n}\n","/**\n * External dependencies\n */\nimport { find, isNil } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport {\n\tforwardRef,\n\tuseEffect,\n\tuseRef,\n\tuseState,\n\tuseMemo,\n\tuseLayoutEffect,\n} from '@wordpress/element';\nimport {\n\tBACKSPACE,\n\tDELETE,\n\tENTER,\n\tLEFT,\n\tRIGHT,\n\tSPACE,\n\tESCAPE,\n} from '@wordpress/keycodes';\nimport deprecated from '@wordpress/deprecated';\n\n/**\n * Internal dependencies\n */\nimport FormatEdit from './format-edit';\nimport { create } from '../create';\nimport { apply } from '../to-dom';\nimport { toHTMLString } from '../to-html-string';\nimport { remove } from '../remove';\nimport { removeFormat } from '../remove-format';\nimport { isCollapsed } from '../is-collapsed';\nimport { LINE_SEPARATOR } from '../special-characters';\nimport { indentListItems } from '../indent-list-items';\nimport { getActiveFormats } from '../get-active-formats';\nimport { updateFormats } from '../update-formats';\nimport { removeLineSeparator } from '../remove-line-separator';\nimport { isEmptyLine } from '../is-empty';\nimport { useFormatTypes } from './use-format-types';\nimport { useBoundaryStyle } from './use-boundary-style';\nimport { useInlineWarning } from './use-inline-warning';\nimport { insert } from '../insert';\n\n/** @typedef {import('@wordpress/element').WPSyntheticEvent} WPSyntheticEvent */\n\n/**\n * All inserting input types that would insert HTML into the DOM.\n *\n * @see https://www.w3.org/TR/input-events-2/#interface-InputEvent-Attributes\n *\n * @type {Set}\n */\nconst INSERTION_INPUT_TYPES_TO_IGNORE = new Set( [\n\t'insertParagraph',\n\t'insertOrderedList',\n\t'insertUnorderedList',\n\t'insertHorizontalRule',\n\t'insertLink',\n] );\n\n/**\n * In HTML, leading and trailing spaces are not visible, and multiple spaces\n * elsewhere are visually reduced to one space. This rule prevents spaces from\n * collapsing so all space is visible in the editor and can be removed. It also\n * prevents some browsers from inserting non-breaking spaces at the end of a\n * line to prevent the space from visually disappearing. Sometimes these non\n * breaking spaces can linger in the editor causing unwanted non breaking spaces\n * in between words. If also prevent Firefox from inserting a trailing `br` node\n * to visualise any trailing space, causing the element to be saved.\n *\n * > Authors are encouraged to set the 'white-space' property on editing hosts\n * > and on markup that was originally created through these editing mechanisms\n * > to the value 'pre-wrap'. Default HTML whitespace handling is not well\n * > suited to WYSIWYG editing, and line wrapping will not work correctly in\n * > some corner cases if 'white-space' is left at its default value.\n *\n * https://html.spec.whatwg.org/multipage/interaction.html#best-practices-for-in-page-editors\n *\n * @type {string}\n */\nconst whiteSpace = 'pre-wrap';\n\n/**\n * Default style object for the editable element.\n *\n * @type {Object<string,string>}\n */\nconst defaultStyle = { whiteSpace };\n\nconst EMPTY_ACTIVE_FORMATS = [];\n\nfunction createPrepareEditableTree( fns ) {\n\treturn ( value ) =>\n\t\tfns.reduce(\n\t\t\t( accumulator, fn ) => fn( accumulator, value.text ),\n\t\t\tvalue.formats\n\t\t);\n}\n\n/**\n * If the selection is set on the placeholder element, collapse the selection to\n * the start (before the placeholder).\n *\n * @param {Window} defaultView\n */\nfunction fixPlaceholderSelection( defaultView ) {\n\tconst selection = defaultView.getSelection();\n\tconst { anchorNode, anchorOffset } = selection;\n\n\tif ( anchorNode.nodeType !== anchorNode.ELEMENT_NODE ) {\n\t\treturn;\n\t}\n\n\tconst targetNode = anchorNode.childNodes[ anchorOffset ];\n\n\tif (\n\t\t! targetNode ||\n\t\ttargetNode.nodeType !== targetNode.ELEMENT_NODE ||\n\t\t! targetNode.getAttribute( 'data-rich-text-placeholder' )\n\t) {\n\t\treturn;\n\t}\n\n\tselection.collapseToStart();\n}\n\nfunction RichText(\n\t{\n\t\ttagName: TagName = 'div',\n\t\tvalue = '',\n\t\tselectionStart,\n\t\tselectionEnd,\n\t\tchildren,\n\t\tallowedFormats,\n\t\twithoutInteractiveFormatting,\n\t\tplaceholder,\n\t\tdisabled,\n\t\tpreserveWhiteSpace,\n\t\tonPaste,\n\t\tformat = 'string',\n\t\tonDelete,\n\t\tonEnter,\n\t\tonSelectionChange,\n\t\tonChange,\n\t\tunstableOnFocus: onFocus,\n\t\tsetFocusedElement,\n\t\tinstanceId,\n\t\tclientId,\n\t\tidentifier,\n\t\t__unstableMultilineTag: multilineTag,\n\t\t__unstableMultilineRootTag: multilineRootTag,\n\t\t__unstableDisableFormats: disableFormats,\n\t\t__unstableDidAutomaticChange: didAutomaticChange,\n\t\t__unstableInputRule: inputRule,\n\t\t__unstableMarkAutomaticChange: markAutomaticChange,\n\t\t__unstableAllowPrefixTransformations: allowPrefixTransformations,\n\t\t__unstableUndo: undo,\n\t\t__unstableIsCaretWithinFormattedText: isCaretWithinFormattedText,\n\t\t__unstableOnEnterFormattedText: onEnterFormattedText,\n\t\t__unstableOnExitFormattedText: onExitFormattedText,\n\t\t__unstableOnCreateUndoLevel: onCreateUndoLevel,\n\t\t__unstableIsSelected: isSelected,\n\t},\n\tref\n) {\n\tconst [ activeFormats = [], setActiveFormats ] = useState();\n\tconst {\n\t\tformatTypes,\n\t\tprepareHandlers,\n\t\tvalueHandlers,\n\t\tchangeHandlers,\n\t\tdependencies,\n\t} = useFormatTypes( {\n\t\tclientId,\n\t\tidentifier,\n\t} );\n\n\t// For backward compatibility, fall back to tagName if it's a string.\n\t// tagName can now be a component for light blocks.\n\tif ( ! multilineRootTag && typeof TagName === 'string' ) {\n\t\tmultilineRootTag = TagName;\n\t}\n\n\tfunction getDoc() {\n\t\treturn ref.current.ownerDocument;\n\t}\n\n\tfunction getWin() {\n\t\treturn getDoc().defaultView;\n\t}\n\n\t/**\n\t * Converts the outside data structure to our internal representation.\n\t *\n\t * @param {*} string The outside value, data type depends on props.\n\t *\n\t * @return {Object} An internal rich-text value.\n\t */\n\tfunction formatToValue( string ) {\n\t\tif ( disableFormats ) {\n\t\t\treturn {\n\t\t\t\ttext: string,\n\t\t\t\tformats: Array( string.length ),\n\t\t\t\treplacements: Array( string.length ),\n\t\t\t};\n\t\t}\n\n\t\tif ( format !== 'string' ) {\n\t\t\treturn string;\n\t\t}\n\n\t\tconst prepare = createPrepareEditableTree( valueHandlers );\n\n\t\tconst result = create( {\n\t\t\thtml: string,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\tresult.formats = prepare( result );\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Removes editor only formats from the value.\n\t *\n\t * Editor only formats are applied using `prepareEditableTree`, so we need to\n\t * remove them before converting the internal state\n\t *\n\t * @param {Object} val The internal rich-text value.\n\t *\n\t * @return {Object} A new rich-text value.\n\t */\n\tfunction removeEditorOnlyFormats( val ) {\n\t\tformatTypes.forEach( ( formatType ) => {\n\t\t\t// Remove formats created by prepareEditableTree, because they are editor only.\n\t\t\tif ( formatType.__experimentalCreatePrepareEditableTree ) {\n\t\t\t\tval = removeFormat( val, formatType.name, 0, val.text.length );\n\t\t\t}\n\t\t} );\n\n\t\treturn val;\n\t}\n\n\t/**\n\t * Converts the internal value to the external data format.\n\t *\n\t * @param {Object} val The internal rich-text value.\n\t *\n\t * @return {*} The external data format, data type depends on props.\n\t */\n\tfunction valueToFormat( val ) {\n\t\tif ( disableFormats ) {\n\t\t\treturn val.text;\n\t\t}\n\n\t\tval = removeEditorOnlyFormats( val );\n\n\t\tif ( format !== 'string' ) {\n\t\t\treturn;\n\t\t}\n\n\t\treturn toHTMLString( { value: val, multilineTag, preserveWhiteSpace } );\n\t}\n\n\t// Internal values are updated synchronously, unlike props and state.\n\tconst _value = useRef( value );\n\tconst record = useRef(\n\t\tuseMemo( () => {\n\t\t\tconst initialRecord = formatToValue( value );\n\t\t\tinitialRecord.start = selectionStart;\n\t\t\tinitialRecord.end = selectionEnd;\n\t\t\treturn initialRecord;\n\t\t}, [] )\n\t);\n\n\tfunction createRecord() {\n\t\tconst selection = getWin().getSelection();\n\t\tconst range =\n\t\t\tselection.rangeCount > 0 ? selection.getRangeAt( 0 ) : null;\n\n\t\treturn create( {\n\t\t\telement: ref.current,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\t__unstableIsEditableTree: true,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t}\n\n\tfunction applyRecord( newRecord, { domOnly } = {} ) {\n\t\tapply( {\n\t\t\tvalue: newRecord,\n\t\t\tcurrent: ref.current,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags:\n\t\t\t\tmultilineTag === 'li' ? [ 'ul', 'ol' ] : undefined,\n\t\t\tprepareEditableTree: createPrepareEditableTree( prepareHandlers ),\n\t\t\t__unstableDomOnly: domOnly,\n\t\t\tplaceholder,\n\t\t} );\n\t}\n\n\t/**\n\t * Handles a paste event.\n\t *\n\t * Saves the pasted data as plain text in `pastedPlainText`.\n\t *\n\t * @param {ClipboardEvent} event The paste event.\n\t */\n\tfunction handlePaste( event ) {\n\t\tif ( ! isSelected ) {\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tconst clipboardData = event.clipboardData;\n\t\tlet { items, files } = clipboardData;\n\n\t\t// In Edge these properties can be null instead of undefined, so a more\n\t\t// rigorous test is required over using default values.\n\t\titems = isNil( items ) ? [] : items;\n\t\tfiles = isNil( files ) ? [] : files;\n\n\t\tlet plainText = '';\n\t\tlet html = '';\n\n\t\t// IE11 only supports `Text` as an argument for `getData` and will\n\t\t// otherwise throw an invalid argument error, so we try the standard\n\t\t// arguments first, then fallback to `Text` if they fail.\n\t\ttry {\n\t\t\tplainText = clipboardData.getData( 'text/plain' );\n\t\t\thtml = clipboardData.getData( 'text/html' );\n\t\t} catch ( error1 ) {\n\t\t\ttry {\n\t\t\t\thtml = clipboardData.getData( 'Text' );\n\t\t\t} catch ( error2 ) {\n\t\t\t\t// Some browsers like UC Browser paste plain text by default and\n\t\t\t\t// don't support clipboardData at all, so allow default\n\t\t\t\t// behaviour.\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\t// Allows us to ask for this information when we get a report.\n\t\twindow.console.log( 'Received HTML:\\n\\n', html );\n\t\twindow.console.log( 'Received plain text:\\n\\n', plainText );\n\n\t\tif ( disableFormats ) {\n\t\t\thandleChange( insert( record.current, plainText ) );\n\t\t\treturn;\n\t\t}\n\n\t\tconst transformed = formatTypes.reduce(\n\t\t\t( accumlator, { __unstablePasteRule } ) => {\n\t\t\t\t// Only allow one transform.\n\t\t\t\tif ( __unstablePasteRule && accumlator === record.current ) {\n\t\t\t\t\taccumlator = __unstablePasteRule( record.current, {\n\t\t\t\t\t\thtml,\n\t\t\t\t\t\tplainText,\n\t\t\t\t\t} );\n\t\t\t\t}\n\n\t\t\t\treturn accumlator;\n\t\t\t},\n\t\t\trecord.current\n\t\t);\n\n\t\tif ( transformed !== record.current ) {\n\t\t\thandleChange( transformed );\n\t\t\treturn;\n\t\t}\n\n\t\tif ( onPaste ) {\n\t\t\tfiles = Array.from( files );\n\n\t\t\tArray.from( items ).forEach( ( item ) => {\n\t\t\t\tif ( ! item.getAsFile ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst file = item.getAsFile();\n\n\t\t\t\tif ( ! file ) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { name, type, size } = file;\n\n\t\t\t\tif ( ! find( files, { name, type, size } ) ) {\n\t\t\t\t\tfiles.push( file );\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tonPaste( {\n\t\t\t\tvalue: removeEditorOnlyFormats( record.current ),\n\t\t\t\tonChange: handleChange,\n\t\t\t\thtml,\n\t\t\t\tplainText,\n\t\t\t\tfiles,\n\t\t\t\tactiveFormats,\n\t\t\t} );\n\t\t}\n\t}\n\n\t/**\n\t * Handles delete on keydown:\n\t * - outdent list items,\n\t * - delete content if everything is selected,\n\t * - trigger the onDelete prop when selection is uncollapsed and at an edge.\n\t *\n\t * @param {WPSyntheticEvent} event A synthetic keyboard event.\n\t */\n\tfunction handleDelete( event ) {\n\t\tconst { keyCode } = event;\n\n\t\tif (\n\t\t\tkeyCode !== DELETE &&\n\t\t\tkeyCode !== BACKSPACE &&\n\t\t\tkeyCode !== ESCAPE\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( didAutomaticChange ) {\n\t\t\tevent.preventDefault();\n\t\t\tundo();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( keyCode === ESCAPE ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, end, text } = currentValue;\n\t\tconst isReverse = keyCode === BACKSPACE;\n\n\t\t// Always handle full content deletion ourselves.\n\t\tif ( start === 0 && end !== 0 && end === text.length ) {\n\t\t\thandleChange( remove( currentValue ) );\n\t\t\tevent.preventDefault();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( multilineTag ) {\n\t\t\tlet newValue;\n\n\t\t\t// Check to see if we should remove the first item if empty.\n\t\t\tif (\n\t\t\t\tisReverse &&\n\t\t\t\tcurrentValue.start === 0 &&\n\t\t\t\tcurrentValue.end === 0 &&\n\t\t\t\tisEmptyLine( currentValue )\n\t\t\t) {\n\t\t\t\tnewValue = removeLineSeparator( currentValue, ! isReverse );\n\t\t\t} else {\n\t\t\t\tnewValue = removeLineSeparator( currentValue, isReverse );\n\t\t\t}\n\n\t\t\tif ( newValue ) {\n\t\t\t\thandleChange( newValue );\n\t\t\t\tevent.preventDefault();\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// Only process delete if the key press occurs at an uncollapsed edge.\n\t\tif (\n\t\t\t! onDelete ||\n\t\t\t! isCollapsed( currentValue ) ||\n\t\t\tactiveFormats.length ||\n\t\t\t( isReverse && start !== 0 ) ||\n\t\t\t( ! isReverse && end !== text.length )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tonDelete( { isReverse, value: currentValue } );\n\t\tevent.preventDefault();\n\t}\n\n\t/**\n\t * Triggers the `onEnter` prop on keydown.\n\t *\n\t * @param {WPSyntheticEvent} event A synthetic keyboard event.\n\t */\n\tfunction handleEnter( event ) {\n\t\tif ( event.keyCode !== ENTER ) {\n\t\t\treturn;\n\t\t}\n\n\t\tevent.preventDefault();\n\n\t\tif ( ! onEnter ) {\n\t\t\treturn;\n\t\t}\n\n\t\tonEnter( {\n\t\t\tvalue: removeEditorOnlyFormats( createRecord() ),\n\t\t\tonChange: handleChange,\n\t\t\tshiftKey: event.shiftKey,\n\t\t} );\n\t}\n\n\t/**\n\t * Indents list items on space keydown.\n\t *\n\t * @param {WPSyntheticEvent} event A synthetic keyboard event.\n\t */\n\tfunction handleSpace( event ) {\n\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\tif (\n\t\t\t// Only override when no modifiers are pressed.\n\t\t\tshiftKey ||\n\t\t\taltKey ||\n\t\t\tmetaKey ||\n\t\t\tctrlKey ||\n\t\t\tkeyCode !== SPACE ||\n\t\t\tmultilineTag !== 'li'\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\n\t\tif ( ! isCollapsed( currentValue ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { text, start } = currentValue;\n\t\tconst characterBefore = text[ start - 1 ];\n\n\t\t// The caret must be at the start of a line.\n\t\tif ( characterBefore && characterBefore !== LINE_SEPARATOR ) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleChange(\n\t\t\tindentListItems( currentValue, { type: multilineRootTag } )\n\t\t);\n\t\tevent.preventDefault();\n\t}\n\n\t/**\n\t * Handles horizontal keyboard navigation when no modifiers are pressed. The\n\t * navigation is handled separately to move correctly around format\n\t * boundaries.\n\t *\n\t * @param {WPSyntheticEvent} event A synthetic keyboard event.\n\t */\n\tfunction handleHorizontalNavigation( event ) {\n\t\tconst { keyCode, shiftKey, altKey, metaKey, ctrlKey } = event;\n\n\t\tif (\n\t\t\t// Only override left and right keys without modifiers pressed.\n\t\t\tshiftKey ||\n\t\t\taltKey ||\n\t\t\tmetaKey ||\n\t\t\tctrlKey ||\n\t\t\t( keyCode !== LEFT && keyCode !== RIGHT )\n\t\t) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst {\n\t\t\ttext,\n\t\t\tformats,\n\t\t\tstart,\n\t\t\tend,\n\t\t\tactiveFormats: currentActiveFormats = [],\n\t\t} = record.current;\n\t\tconst collapsed = isCollapsed( record.current );\n\t\t// To do: ideally, we should look at visual position instead.\n\t\tconst { direction } = getWin().getComputedStyle( ref.current );\n\t\tconst reverseKey = direction === 'rtl' ? RIGHT : LEFT;\n\t\tconst isReverse = event.keyCode === reverseKey;\n\n\t\t// If the selection is collapsed and at the very start, do nothing if\n\t\t// navigating backward.\n\t\t// If the selection is collapsed and at the very end, do nothing if\n\t\t// navigating forward.\n\t\tif ( collapsed && currentActiveFormats.length === 0 ) {\n\t\t\tif ( start === 0 && isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif ( end === text.length && ! isReverse ) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\t// If the selection is not collapsed, let the browser handle collapsing\n\t\t// the selection for now. Later we could expand this logic to set\n\t\t// boundary positions if needed.\n\t\tif ( ! collapsed ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In all other cases, prevent default behaviour.\n\t\tevent.preventDefault();\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\tlet newActiveFormatsLength = currentActiveFormats.length;\n\t\tlet source = formatsAfter;\n\n\t\tif ( formatsBefore.length > formatsAfter.length ) {\n\t\t\tsource = formatsBefore;\n\t\t}\n\n\t\t// If the amount of formats before the caret and after the caret is\n\t\t// different, the caret is at a format boundary.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\tif (\n\t\t\t\t! isReverse &&\n\t\t\t\tcurrentActiveFormats.length < formatsAfter.length\n\t\t\t) {\n\t\t\t\tnewActiveFormatsLength++;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tisReverse &&\n\t\t\t\tcurrentActiveFormats.length > formatsBefore.length\n\t\t\t) {\n\t\t\t\tnewActiveFormatsLength--;\n\t\t\t}\n\t\t} else if ( formatsBefore.length > formatsAfter.length ) {\n\t\t\tif (\n\t\t\t\t! isReverse &&\n\t\t\t\tcurrentActiveFormats.length > formatsAfter.length\n\t\t\t) {\n\t\t\t\tnewActiveFormatsLength--;\n\t\t\t}\n\n\t\t\tif (\n\t\t\t\tisReverse &&\n\t\t\t\tcurrentActiveFormats.length < formatsBefore.length\n\t\t\t) {\n\t\t\t\tnewActiveFormatsLength++;\n\t\t\t}\n\t\t}\n\n\t\tif ( newActiveFormatsLength !== currentActiveFormats.length ) {\n\t\t\tconst newActiveFormats = source.slice( 0, newActiveFormatsLength );\n\t\t\tconst newValue = {\n\t\t\t\t...record.current,\n\t\t\t\tactiveFormats: newActiveFormats,\n\t\t\t};\n\t\t\trecord.current = newValue;\n\t\t\tapplyRecord( newValue );\n\t\t\tsetActiveFormats( newActiveFormats );\n\t\t\treturn;\n\t\t}\n\n\t\tconst newPos = start + ( isReverse ? -1 : 1 );\n\t\tconst newActiveFormats = isReverse ? formatsBefore : formatsAfter;\n\t\tconst newValue = {\n\t\t\t...record.current,\n\t\t\tstart: newPos,\n\t\t\tend: newPos,\n\t\t\tactiveFormats: newActiveFormats,\n\t\t};\n\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue );\n\t\tonSelectionChange( newPos, newPos );\n\t\tsetActiveFormats( newActiveFormats );\n\t}\n\n\tfunction handleKeyDown( event ) {\n\t\tif ( event.defaultPrevented ) {\n\t\t\treturn;\n\t\t}\n\n\t\thandleDelete( event );\n\t\thandleEnter( event );\n\t\thandleSpace( event );\n\t\thandleHorizontalNavigation( event );\n\t}\n\n\tconst lastHistoryValue = useRef( value );\n\n\tfunction createUndoLevel() {\n\t\t// If the content is the same, no level needs to be created.\n\t\tif ( lastHistoryValue.current === _value.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tonCreateUndoLevel();\n\t\tlastHistoryValue.current = _value.current;\n\t}\n\n\tconst isComposing = useRef( false );\n\tconst timeout = useRef();\n\n\t/**\n\t * Handle input on the next selection change event.\n\t *\n\t * @param {WPSyntheticEvent} event Synthetic input event.\n\t */\n\tfunction handleInput( event ) {\n\t\t// Do not trigger a change if characters are being composed. Browsers\n\t\t// will usually emit a final `input` event when the characters are\n\t\t// composed.\n\t\t// As of December 2019, Safari doesn't support nativeEvent.isComposing.\n\t\tif ( isComposing.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tlet inputType;\n\n\t\tif ( event ) {\n\t\t\tinputType = event.inputType;\n\t\t}\n\n\t\tif ( ! inputType && event && event.nativeEvent ) {\n\t\t\tinputType = event.nativeEvent.inputType;\n\t\t}\n\n\t\t// The browser formatted something or tried to insert HTML.\n\t\t// Overwrite it. It will be handled later by the format library if\n\t\t// needed.\n\t\tif (\n\t\t\tinputType &&\n\t\t\t( inputType.indexOf( 'format' ) === 0 ||\n\t\t\t\tINSERTION_INPUT_TYPES_TO_IGNORE.has( inputType ) )\n\t\t) {\n\t\t\tapplyRecord( record.current );\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentValue = createRecord();\n\t\tconst { start, activeFormats: oldActiveFormats = [] } = record.current;\n\n\t\t// Update the formats between the last and new caret position.\n\t\tconst change = updateFormats( {\n\t\t\tvalue: currentValue,\n\t\t\tstart,\n\t\t\tend: currentValue.start,\n\t\t\tformats: oldActiveFormats,\n\t\t} );\n\n\t\thandleChange( change, { withoutHistory: true } );\n\n\t\t// Create an undo level when input stops for over a second.\n\t\tgetWin().clearTimeout( timeout.current );\n\t\ttimeout.current = getWin().setTimeout( createUndoLevel, 1000 );\n\n\t\t// Only run input rules when inserting text.\n\t\tif ( inputType !== 'insertText' ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( allowPrefixTransformations && inputRule ) {\n\t\t\tinputRule( change, valueToFormat );\n\t\t}\n\n\t\tconst transformed = formatTypes.reduce(\n\t\t\t( accumlator, { __unstableInputRule } ) => {\n\t\t\t\tif ( __unstableInputRule ) {\n\t\t\t\t\taccumlator = __unstableInputRule( accumlator );\n\t\t\t\t}\n\n\t\t\t\treturn accumlator;\n\t\t\t},\n\t\t\tchange\n\t\t);\n\n\t\tif ( transformed !== change ) {\n\t\t\tcreateUndoLevel();\n\t\t\thandleChange( { ...transformed, activeFormats: oldActiveFormats } );\n\t\t\tmarkAutomaticChange();\n\t\t}\n\t}\n\n\tfunction handleCompositionStart() {\n\t\tisComposing.current = true;\n\t\t// Do not update the selection when characters are being composed as\n\t\t// this rerenders the component and might distroy internal browser\n\t\t// editing state.\n\t\tgetDoc().removeEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\tfunction handleCompositionEnd() {\n\t\tisComposing.current = false;\n\t\t// Ensure the value is up-to-date for browsers that don't emit a final\n\t\t// input event after composition.\n\t\thandleInput( { inputType: 'insertText' } );\n\t\t// Tracking selection changes can be resumed.\n\t\tgetDoc().addEventListener( 'selectionchange', handleSelectionChange );\n\t}\n\n\tconst didMount = useRef( false );\n\n\t/**\n\t * Syncs the selection to local state. A callback for the `selectionchange`\n\t * native events, `keyup`, `mouseup` and `touchend` synthetic events, and\n\t * animation frames after the `focus` event.\n\t *\n\t * @param {Event|WPSyntheticEvent|DOMHighResTimeStamp} event\n\t */\n\tfunction handleSelectionChange( event ) {\n\t\tif ( ! ref.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( ref.current.ownerDocument.activeElement !== ref.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( event.type !== 'selectionchange' && ! isSelected ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif ( disabled ) {\n\t\t\treturn;\n\t\t}\n\n\t\t// In case of a keyboard event, ignore selection changes during\n\t\t// composition.\n\t\tif ( isComposing.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { start, end, text } = createRecord();\n\t\tconst oldRecord = record.current;\n\n\t\t// Fallback mechanism for IE11, which doesn't support the input event.\n\t\t// Any input results in a selection change.\n\t\tif ( text !== oldRecord.text ) {\n\t\t\thandleInput();\n\t\t\treturn;\n\t\t}\n\n\t\tif ( start === oldRecord.start && end === oldRecord.end ) {\n\t\t\t// Sometimes the browser may set the selection on the placeholder\n\t\t\t// element, in which case the caret is not visible. We need to set\n\t\t\t// the caret before the placeholder if that's the case.\n\t\t\tif ( oldRecord.text.length === 0 && start === 0 ) {\n\t\t\t\tfixPlaceholderSelection( getWin() );\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst newValue = {\n\t\t\t...oldRecord,\n\t\t\tstart,\n\t\t\tend,\n\t\t\t// Allow `getActiveFormats` to get new `activeFormats`.\n\t\t\tactiveFormats: undefined,\n\t\t};\n\n\t\tconst newActiveFormats = getActiveFormats(\n\t\t\tnewValue,\n\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t);\n\n\t\t// Update the value with the new active formats.\n\t\tnewValue.activeFormats = newActiveFormats;\n\n\t\tif ( ! isCaretWithinFormattedText && newActiveFormats.length ) {\n\t\t\tonEnterFormattedText();\n\t\t} else if ( isCaretWithinFormattedText && ! newActiveFormats.length ) {\n\t\t\tonExitFormattedText();\n\t\t}\n\n\t\t// It is important that the internal value is updated first,\n\t\t// otherwise the value will be wrong on render!\n\t\trecord.current = newValue;\n\t\tapplyRecord( newValue, { domOnly: true } );\n\t\tonSelectionChange( start, end );\n\t\tsetActiveFormats( newActiveFormats );\n\t}\n\n\t/**\n\t * Sync the value to global state. The node tree and selection will also be\n\t * updated if differences are found.\n\t *\n\t * @param {Object}  newRecord         The record to sync and apply.\n\t * @param {Object}  $2                Named options.\n\t * @param {boolean} $2.withoutHistory If true, no undo level will be\n\t *                                    created.\n\t */\n\tfunction handleChange( newRecord, { withoutHistory } = {} ) {\n\t\tif ( disableFormats ) {\n\t\t\tnewRecord.formats = Array( newRecord.text.length );\n\t\t\tnewRecord.replacements = Array( newRecord.text.length );\n\t\t}\n\n\t\tapplyRecord( newRecord );\n\n\t\tconst { start, end, activeFormats: newActiveFormats = [] } = newRecord;\n\n\t\tObject.values( changeHandlers ).forEach( ( changeHandler ) => {\n\t\t\tchangeHandler( newRecord.formats, newRecord.text );\n\t\t} );\n\n\t\t_value.current = valueToFormat( newRecord );\n\t\trecord.current = newRecord;\n\n\t\t// Selection must be updated first, so it is recorded in history when\n\t\t// the content change happens.\n\t\tonSelectionChange( start, end );\n\t\tonChange( _value.current );\n\t\tsetActiveFormats( newActiveFormats );\n\n\t\tif ( ! withoutHistory ) {\n\t\t\tcreateUndoLevel();\n\t\t}\n\t}\n\n\t/**\n\t * Select object when they are clicked. The browser will not set any\n\t * selection when clicking e.g. an image.\n\t *\n\t * @param {WPSyntheticEvent} event Synthetic mousedown or touchstart event.\n\t */\n\tfunction handlePointerDown( event ) {\n\t\tconst { target } = event;\n\n\t\t// If the child element has no text content, it must be an object.\n\t\tif ( target === ref.current || target.textContent ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { parentNode } = target;\n\t\tconst index = Array.from( parentNode.childNodes ).indexOf( target );\n\t\tconst range = getDoc().createRange();\n\t\tconst selection = getWin().getSelection();\n\n\t\trange.setStart( target.parentNode, index );\n\t\trange.setEnd( target.parentNode, index + 1 );\n\n\t\tselection.removeAllRanges();\n\t\tselection.addRange( range );\n\t}\n\n\tconst rafId = useRef();\n\n\t/**\n\t * Handles a focus event on the contenteditable field, calling the\n\t * `unstableOnFocus` prop callback if one is defined. The callback does not\n\t * receive any arguments.\n\t *\n\t * This is marked as a private API and the `unstableOnFocus` prop is not\n\t * documented, as the current requirements where it is used are subject to\n\t * future refactoring following `isSelected` handling.\n\t *\n\t * In contrast with `setFocusedElement`, this is only triggered in response\n\t * to focus within the contenteditable field, whereas `setFocusedElement`\n\t * is triggered on focus within any `RichText` descendent element.\n\t *\n\t * @see setFocusedElement\n\t *\n\t * @private\n\t */\n\tfunction handleFocus() {\n\t\tif ( onFocus ) {\n\t\t\tonFocus();\n\t\t}\n\n\t\tif ( ! isSelected ) {\n\t\t\t// We know for certain that on focus, the old selection is invalid.\n\t\t\t// It will be recalculated on the next mouseup, keyup, or touchend\n\t\t\t// event.\n\t\t\tconst index = undefined;\n\n\t\t\trecord.current = {\n\t\t\t\t...record.current,\n\t\t\t\tstart: index,\n\t\t\t\tend: index,\n\t\t\t\tactiveFormats: EMPTY_ACTIVE_FORMATS,\n\t\t\t};\n\t\t\tonSelectionChange( index, index );\n\t\t\tsetActiveFormats( EMPTY_ACTIVE_FORMATS );\n\t\t} else {\n\t\t\tonSelectionChange( record.current.start, record.current.end );\n\t\t\tsetActiveFormats(\n\t\t\t\tgetActiveFormats(\n\t\t\t\t\t{\n\t\t\t\t\t\t...record.current,\n\t\t\t\t\t\tactiveFormats: undefined,\n\t\t\t\t\t},\n\t\t\t\t\tEMPTY_ACTIVE_FORMATS\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\t// Update selection as soon as possible, which is at the next animation\n\t\t// frame. The event listener for selection changes may be added too late\n\t\t// at this point, but this focus event is still too early to calculate\n\t\t// the selection.\n\t\trafId.current = getWin().requestAnimationFrame( handleSelectionChange );\n\n\t\tgetDoc().addEventListener( 'selectionchange', handleSelectionChange );\n\n\t\tif ( setFocusedElement ) {\n\t\t\tdeprecated( 'wp.blockEditor.RichText setFocusedElement prop', {\n\t\t\t\talternative: 'selection state from the block editor store.',\n\t\t\t} );\n\t\t\tsetFocusedElement( instanceId );\n\t\t}\n\t}\n\n\tfunction handleBlur() {\n\t\tgetDoc().removeEventListener(\n\t\t\t'selectionchange',\n\t\t\thandleSelectionChange\n\t\t);\n\t}\n\n\tfunction applyFromProps() {\n\t\t_value.current = value;\n\t\trecord.current = formatToValue( value );\n\t\trecord.current.start = selectionStart;\n\t\trecord.current.end = selectionEnd;\n\t\tapplyRecord( record.current );\n\t}\n\n\tuseEffect( () => {\n\t\tif ( didMount.current ) {\n\t\t\tapplyFromProps();\n\t\t}\n\t}, [ TagName, placeholder ] );\n\n\tuseEffect( () => {\n\t\tif ( didMount.current && value !== _value.current ) {\n\t\t\tapplyFromProps();\n\t\t}\n\t}, [ value ] );\n\n\tuseEffect( () => {\n\t\tif ( ! didMount.current ) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (\n\t\t\tisSelected &&\n\t\t\t( selectionStart !== record.current.start ||\n\t\t\t\tselectionEnd !== record.current.end )\n\t\t) {\n\t\t\tapplyFromProps();\n\t\t} else {\n\t\t\trecord.current = {\n\t\t\t\t...record.current,\n\t\t\t\tstart: selectionStart,\n\t\t\t\tend: selectionEnd,\n\t\t\t};\n\t\t}\n\t}, [ selectionStart, selectionEnd, isSelected ] );\n\n\tuseEffect( () => {\n\t\tif ( didMount.current ) {\n\t\t\tapplyFromProps();\n\t\t}\n\t}, dependencies );\n\n\tuseLayoutEffect( () => {\n\t\tapplyRecord( record.current, { domOnly: true } );\n\n\t\tdidMount.current = true;\n\n\t\treturn () => {\n\t\t\tgetDoc().removeEventListener(\n\t\t\t\t'selectionchange',\n\t\t\t\thandleSelectionChange\n\t\t\t);\n\t\t\tgetWin().cancelAnimationFrame( rafId.current );\n\t\t\tgetWin().clearTimeout( timeout.current );\n\t\t};\n\t}, [] );\n\n\tfunction focus() {\n\t\tref.current.focus();\n\t\tapplyRecord( record.current );\n\t}\n\n\tconst editableProps = {\n\t\t// Overridable props.\n\t\trole: 'textbox',\n\t\t'aria-multiline': true,\n\t\t'aria-label': placeholder,\n\t\tref,\n\t\tstyle: defaultStyle,\n\t\tclassName: 'rich-text',\n\t\tonPaste: handlePaste,\n\t\tonInput: handleInput,\n\t\tonCompositionStart: handleCompositionStart,\n\t\tonCompositionEnd: handleCompositionEnd,\n\t\tonKeyDown: handleKeyDown,\n\t\tonFocus: handleFocus,\n\t\tonBlur: handleBlur,\n\t\tonMouseDown: handlePointerDown,\n\t\tonTouchStart: handlePointerDown,\n\t\t// Selection updates must be done at these events as they\n\t\t// happen before the `selectionchange` event. In some cases,\n\t\t// the `selectionchange` event may not even fire, for\n\t\t// example when the window receives focus again on click.\n\t\tonKeyUp: handleSelectionChange,\n\t\tonMouseUp: handleSelectionChange,\n\t\tonTouchEnd: handleSelectionChange,\n\t\t// Do not set the attribute if disabled.\n\t\tcontentEditable: disabled ? undefined : true,\n\t\tsuppressContentEditableWarning: ! disabled,\n\t};\n\n\tuseBoundaryStyle( { ref, activeFormats } );\n\tuseInlineWarning( { ref } );\n\n\treturn (\n\t\t<>\n\t\t\t{ isSelected && (\n\t\t\t\t<FormatEdit\n\t\t\t\t\tallowedFormats={ allowedFormats }\n\t\t\t\t\twithoutInteractiveFormatting={\n\t\t\t\t\t\twithoutInteractiveFormatting\n\t\t\t\t\t}\n\t\t\t\t\tvalue={ record.current }\n\t\t\t\t\tonChange={ handleChange }\n\t\t\t\t\tonFocus={ focus }\n\t\t\t\t\tformatTypes={ formatTypes }\n\t\t\t\t/>\n\t\t\t) }\n\t\t\t{ children &&\n\t\t\t\tchildren( {\n\t\t\t\t\tisSelected,\n\t\t\t\t\tvalue: record.current,\n\t\t\t\t\tonChange: handleChange,\n\t\t\t\t\tonFocus: focus,\n\t\t\t\t\teditableProps,\n\t\t\t\t\teditableTagName: TagName,\n\t\t\t\t} ) }\n\t\t\t{ ! children && <TagName { ...editableProps } /> }\n\t\t</>\n\t);\n}\n\n/**\n * Renders a rich content input, providing users with the option to format the\n * content.\n */\nexport default forwardRef( RichText );\n","/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\n\n/*\n * Calculates and renders the format boundary style when the active formats\n * change.\n */\nexport function useBoundaryStyle( { activeFormats, ref } ) {\n\tuseEffect( () => {\n\t\t// There's no need to recalculate the boundary styles if no formats are\n\t\t// active, because no boundary styles will be visible.\n\t\tif ( ! activeFormats || ! activeFormats.length ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst boundarySelector = '*[data-rich-text-format-boundary]';\n\t\tconst element = ref.current.querySelector( boundarySelector );\n\n\t\tif ( ! element ) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst { ownerDocument } = element;\n\t\tconst { defaultView } = ownerDocument;\n\t\tconst computedStyle = defaultView.getComputedStyle( element );\n\t\tconst newColor = computedStyle.color\n\t\t\t.replace( ')', ', 0.2)' )\n\t\t\t.replace( 'rgb', 'rgba' );\n\t\tconst selector = `.rich-text:focus ${ boundarySelector }`;\n\t\tconst rule = `background-color: ${ newColor }`;\n\t\tconst style = `${ selector } {${ rule }}`;\n\t\tconst globalStyleId = 'rich-text-boundary-style';\n\n\t\tlet globalStyle = ownerDocument.getElementById( globalStyleId );\n\n\t\tif ( ! globalStyle ) {\n\t\t\tglobalStyle = ownerDocument.createElement( 'style' );\n\t\t\tglobalStyle.id = globalStyleId;\n\t\t\townerDocument.head.appendChild( globalStyle );\n\t\t}\n\n\t\tif ( globalStyle.innerHTML !== style ) {\n\t\t\tglobalStyle.innerHTML = style;\n\t\t}\n\t}, [ activeFormats ] );\n}\n","/**\n * WordPress dependencies\n */\nimport { useSelect, useDispatch } from '@wordpress/data';\n\nfunction formatTypesSelector( select ) {\n\treturn select( 'core/rich-text' ).getFormatTypes();\n}\n\n/**\n * This hook provides RichText with the `formatTypes` and its derived props from\n * experimental format type settings.\n *\n * @param {Object} $0            Options\n * @param {string} $0.clientId   Block client ID.\n * @param {string} $0.identifier Block attribute.\n */\nexport function useFormatTypes( { clientId, identifier } ) {\n\tconst formatTypes = useSelect( formatTypesSelector, [] );\n\tconst keyedSelected = useSelect(\n\t\t( select ) =>\n\t\t\tformatTypes.reduce( ( accumulator, type ) => {\n\t\t\t\tif ( type.__experimentalGetPropsForEditableTreePreparation ) {\n\t\t\t\t\taccumulator[\n\t\t\t\t\t\ttype.name\n\t\t\t\t\t] = type.__experimentalGetPropsForEditableTreePreparation(\n\t\t\t\t\t\tselect,\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t\t\t}\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\treturn accumulator;\n\t\t\t}, {} ),\n\t\t[ formatTypes, clientId, identifier ]\n\t);\n\tconst dispatch = useDispatch();\n\tconst prepareHandlers = [];\n\tconst valueHandlers = [];\n\tconst changeHandlers = [];\n\tconst dependencies = [];\n\n\tformatTypes.forEach( ( type ) => {\n\t\tif ( type.__experimentalCreatePrepareEditableTree ) {\n\t\t\tconst selected = keyedSelected[ type.name ];\n\t\t\tconst handler = type.__experimentalCreatePrepareEditableTree(\n\t\t\t\tselected,\n\t\t\t\t{\n\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t}\n\t\t\t);\n\n\t\t\tif ( type.__experimentalCreateOnChangeEditableValue ) {\n\t\t\t\tvalueHandlers.push( handler );\n\t\t\t} else {\n\t\t\t\tprepareHandlers.push( handler );\n\t\t\t}\n\n\t\t\tfor ( const key in selected ) {\n\t\t\t\tdependencies.push( selected[ key ] );\n\t\t\t}\n\t\t}\n\n\t\tif ( type.__experimentalCreateOnChangeEditableValue ) {\n\t\t\tlet dispatchers = {};\n\n\t\t\tif ( type.__experimentalGetPropsForEditableTreeChangeHandler ) {\n\t\t\t\tdispatchers = type.__experimentalGetPropsForEditableTreeChangeHandler(\n\t\t\t\t\tdispatch,\n\t\t\t\t\t{\n\t\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t\t}\n\t\t\t\t);\n\t\t\t}\n\n\t\t\tchangeHandlers.push(\n\t\t\t\ttype.__experimentalCreateOnChangeEditableValue(\n\t\t\t\t\t{\n\t\t\t\t\t\t...( keyedSelected[ type.name ] || {} ),\n\t\t\t\t\t\t...dispatchers,\n\t\t\t\t\t},\n\t\t\t\t\t{\n\t\t\t\t\t\trichTextIdentifier: identifier,\n\t\t\t\t\t\tblockClientId: clientId,\n\t\t\t\t\t}\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\t} );\n\n\treturn {\n\t\tformatTypes,\n\t\tprepareHandlers,\n\t\tvalueHandlers,\n\t\tchangeHandlers,\n\t\tdependencies,\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { useEffect } from '@wordpress/element';\n\nexport function useInlineWarning( { ref } ) {\n\tuseEffect( () => {\n\t\tif ( process.env.NODE_ENV === 'development' ) {\n\t\t\tconst target = ref.current;\n\t\t\tconst { defaultView } = target.ownerDocument;\n\t\t\tconst computedStyle = defaultView.getComputedStyle( target );\n\n\t\t\tif ( computedStyle.display === 'inline' ) {\n\t\t\t\t// eslint-disable-next-line no-console\n\t\t\t\tconsole.warn(\n\t\t\t\t\t'RichText cannot be used with an inline container. Please use a different tagName.'\n\t\t\t\t);\n\t\t\t}\n\t\t}\n\t}, [] );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\nimport { create } from './create';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Concats a pair of rich text values. Not that this mutates `a` and does NOT\n * normalise formats!\n *\n * @param {Object} a Value to mutate.\n * @param {Object} b Value to add read from.\n *\n * @return {Object} `a`, mutated.\n */\nexport function mergePair( a, b ) {\n\ta.formats = a.formats.concat( b.formats );\n\ta.replacements = a.replacements.concat( b.replacements );\n\ta.text += b.text;\n\n\treturn a;\n}\n\n/**\n * Combine all Rich Text values into one. This is similar to\n * `String.prototype.concat`.\n *\n * @param {...RichTextValue} values Objects to combine.\n *\n * @return {RichTextValue} A new value combining all given records.\n */\nexport function concat( ...values ) {\n\treturn normaliseFormats( values.reduce( mergePair, create() ) );\n}\n","/**\n * Parse the given HTML into a body element.\n *\n * Note: The current implementation will return a shared reference, reset on\n * each call to `createElement`. Therefore, you should not hold a reference to\n * the value to operate upon asynchronously, as it may have unexpected results.\n *\n * @param {HTMLDocument} document The HTML document to use to parse.\n * @param {string}       html     The HTML to parse.\n *\n * @return {HTMLBodyElement} Body element with parsed HTML.\n */\nexport function createElement( { implementation }, html ) {\n\t// Because `createHTMLDocument` is an expensive operation, and with this\n\t// function being internal to `rich-text` (full control in avoiding a risk\n\t// of asynchronous operations on the shared reference), a single document\n\t// is reused and reset for each call to the function.\n\tif ( ! createElement.body ) {\n\t\tcreateElement.body = implementation.createHTMLDocument( '' ).body;\n\t}\n\n\tcreateElement.body.innerHTML = html;\n\n\treturn createElement.body;\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\nimport { createElement } from './create-element';\nimport { mergePair } from './concat';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\n/**\n * @typedef {Object} RichTextFormat\n *\n * @property {string} type Format type.\n */\n\n/**\n * @typedef {Array<RichTextFormat>} RichTextFormatList\n */\n\n/**\n * @typedef {Object} RichTextValue\n *\n * @property {string}                    text         Text.\n * @property {Array<RichTextFormatList>} formats      Formats.\n * @property {Array<RichTextFormat>}     replacements Replacements.\n * @property {number|undefined}          start        Selection start.\n * @property {number|undefined}          end          Selection end.\n */\n\nfunction createEmptyValue() {\n\treturn {\n\t\tformats: [],\n\t\treplacements: [],\n\t\ttext: '',\n\t};\n}\n\nfunction simpleFindKey( object, value ) {\n\tfor ( const key in object ) {\n\t\tif ( object[ key ] === value ) {\n\t\t\treturn key;\n\t\t}\n\t}\n}\n\nfunction toFormat( { type, attributes } ) {\n\tlet formatType;\n\n\tif ( attributes && attributes.class ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForClassName(\n\t\t\tattributes.class\n\t\t);\n\n\t\tif ( formatType ) {\n\t\t\t// Preserve any additional classes.\n\t\t\tattributes.class = ` ${ attributes.class } `\n\t\t\t\t.replace( ` ${ formatType.className } `, ' ' )\n\t\t\t\t.trim();\n\n\t\t\tif ( ! attributes.class ) {\n\t\t\t\tdelete attributes.class;\n\t\t\t}\n\t\t}\n\t}\n\n\tif ( ! formatType ) {\n\t\tformatType = select( 'core/rich-text' ).getFormatTypeForBareElement(\n\t\t\ttype\n\t\t);\n\t}\n\n\tif ( ! formatType ) {\n\t\treturn attributes ? { type, attributes } : { type };\n\t}\n\n\tif (\n\t\tformatType.__experimentalCreatePrepareEditableTree &&\n\t\t! formatType.__experimentalCreateOnChangeEditableValue\n\t) {\n\t\treturn null;\n\t}\n\n\tif ( ! attributes ) {\n\t\treturn { type: formatType.name };\n\t}\n\n\tconst registeredAttributes = {};\n\tconst unregisteredAttributes = {};\n\n\tfor ( const name in attributes ) {\n\t\tconst key = simpleFindKey( formatType.attributes, name );\n\n\t\tif ( key ) {\n\t\t\tregisteredAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\tunregisteredAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.name,\n\t\tattributes: registeredAttributes,\n\t\tunregisteredAttributes,\n\t};\n}\n\n/**\n * Create a RichText value from an `Element` tree (DOM), an HTML string or a\n * plain text string, with optionally a `Range` object to set the selection. If\n * called without any input, an empty value will be created. If\n * `multilineTag` is provided, any content of direct children whose type matches\n * `multilineTag` will be separated by two newlines. The optional functions can\n * be used to filter out content.\n *\n * A value will have the following shape, which you are strongly encouraged not\n * to modify without the use of helper functions:\n *\n * ```js\n * {\n *   text: string,\n *   formats: Array,\n *   replacements: Array,\n *   ?start: number,\n *   ?end: number,\n * }\n * ```\n *\n * As you can see, text and formatting are separated. `text` holds the text,\n * including any replacement characters for objects and lines. `formats`,\n * `objects` and `lines` are all sparse arrays of the same length as `text`. It\n * holds information about the formatting at the relevant text indices. Finally\n * `start` and `end` state which text indices are selected. They are only\n * provided if a `Range` was given.\n *\n * @param {Object}  [$1]                      Optional named arguments.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {string}  [$1.text]                 Text to create value from.\n * @param {string}  [$1.html]                 HTML to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {boolean} [$1.__unstableIsEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nexport function create( {\n\telement,\n\ttext,\n\thtml,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\t__unstableIsEditableTree: isEditableTree,\n\tpreserveWhiteSpace,\n} = {} ) {\n\tif ( typeof text === 'string' && text.length > 0 ) {\n\t\treturn {\n\t\t\tformats: Array( text.length ),\n\t\t\treplacements: Array( text.length ),\n\t\t\ttext,\n\t\t};\n\t}\n\n\tif ( typeof html === 'string' && html.length > 0 ) {\n\t\t// It does not matter which document this is, we're just using it to\n\t\t// parse.\n\t\telement = createElement( document, html );\n\t}\n\n\tif ( typeof element !== 'object' ) {\n\t\treturn createEmptyValue();\n\t}\n\n\tif ( ! multilineTag ) {\n\t\treturn createFromElement( {\n\t\t\telement,\n\t\t\trange,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\t}\n\n\treturn createFromMultilineElement( {\n\t\telement,\n\t\trange,\n\t\tmultilineTag,\n\t\tmultilineWrapperTags,\n\t\tisEditableTree,\n\t\tpreserveWhiteSpace,\n\t} );\n}\n\n/**\n * Helper to accumulate the value's selection start and end from the current\n * node and range.\n *\n * @param {Object} accumulator Object to accumulate into.\n * @param {Node}   node        Node to create value with.\n * @param {Range}  range       Range to create value with.\n * @param {Object} value       Value that is being accumulated.\n */\nfunction accumulateSelection( accumulator, node, range, value ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { parentNode } = node;\n\tconst { startContainer, startOffset, endContainer, endOffset } = range;\n\tconst currentLength = accumulator.text.length;\n\n\t// Selection can be extracted from value.\n\tif ( value.start !== undefined ) {\n\t\taccumulator.start = currentLength + value.start;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === startContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.start = currentLength + startOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset ]\n\t) {\n\t\taccumulator.start = currentLength;\n\t\t// Range indicates that the selection is after the current node.\n\t} else if (\n\t\tparentNode === startContainer &&\n\t\tnode === startContainer.childNodes[ startOffset - 1 ]\n\t) {\n\t\taccumulator.start = currentLength + value.text.length;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === startContainer ) {\n\t\taccumulator.start = currentLength;\n\t}\n\n\t// Selection can be extracted from value.\n\tif ( value.end !== undefined ) {\n\t\taccumulator.end = currentLength + value.end;\n\t\t// Range indicates that the current node has selection.\n\t} else if ( node === endContainer && node.nodeType === node.TEXT_NODE ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t\t// Range indicates that the current node is selected.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset - 1 ]\n\t) {\n\t\taccumulator.end = currentLength + value.text.length;\n\t\t// Range indicates that the selection is before the current node.\n\t} else if (\n\t\tparentNode === endContainer &&\n\t\tnode === endContainer.childNodes[ endOffset ]\n\t) {\n\t\taccumulator.end = currentLength;\n\t\t// Fallback if no child inside handled the selection.\n\t} else if ( node === endContainer ) {\n\t\taccumulator.end = currentLength + endOffset;\n\t}\n}\n\n/**\n * Adjusts the start and end offsets from a range based on a text filter.\n *\n * @param {Node}     node   Node of which the text should be filtered.\n * @param {Range}    range  The range to filter.\n * @param {Function} filter Function to use to filter the text.\n *\n * @return {Object|void} Object containing range properties.\n */\nfunction filterRange( node, range, filter ) {\n\tif ( ! range ) {\n\t\treturn;\n\t}\n\n\tconst { startContainer, endContainer } = range;\n\tlet { startOffset, endOffset } = range;\n\n\tif ( node === startContainer ) {\n\t\tstartOffset = filter( node.nodeValue.slice( 0, startOffset ) ).length;\n\t}\n\n\tif ( node === endContainer ) {\n\t\tendOffset = filter( node.nodeValue.slice( 0, endOffset ) ).length;\n\t}\n\n\treturn { startContainer, startOffset, endContainer, endOffset };\n}\n\n/**\n * Collapse any whitespace used for HTML formatting to one space character,\n * because it will also be displayed as such by the browser.\n *\n * @param {string} string\n */\nfunction collapseWhiteSpace( string ) {\n\treturn string.replace( /[\\n\\r\\t]+/g, ' ' );\n}\n\nconst ZWNBSPRegExp = new RegExp( ZWNBSP, 'g' );\n\n/**\n * Removes padding (zero width non breaking spaces) added by `toTree`.\n *\n * @param {string} string\n */\nfunction removePadding( string ) {\n\treturn string.replace( ZWNBSPRegExp, '' );\n}\n\n/**\n * Creates a Rich Text value from a DOM element and range.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {Array}   [$1.currentWrapperTags]\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element ) {\n\t\treturn accumulator;\n\t}\n\n\tif ( ! element.hasChildNodes() ) {\n\t\taccumulateSelection( accumulator, element, range, createEmptyValue() );\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.childNodes.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.childNodes[ index ];\n\t\tconst type = node.nodeName.toLowerCase();\n\n\t\tif ( node.nodeType === node.TEXT_NODE ) {\n\t\t\tlet filter = removePadding;\n\n\t\t\tif ( ! preserveWhiteSpace ) {\n\t\t\t\tfilter = ( string ) =>\n\t\t\t\t\tremovePadding( collapseWhiteSpace( string ) );\n\t\t\t}\n\n\t\t\tconst text = filter( node.nodeValue );\n\t\t\trange = filterRange( node, range, filter );\n\t\t\taccumulateSelection( accumulator, node, range, { text } );\n\t\t\t// Create a sparse array of the same length as `text`, in which\n\t\t\t// formats can be added.\n\t\t\taccumulator.formats.length += text.length;\n\t\t\taccumulator.replacements.length += text.length;\n\t\t\taccumulator.text += text;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( node.nodeType !== node.ELEMENT_NODE ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (\n\t\t\tisEditableTree &&\n\t\t\t// Ignore any placeholders.\n\t\t\t( node.getAttribute( 'data-rich-text-placeholder' ) ||\n\t\t\t\t// Ignore any line breaks that are not inserted by us.\n\t\t\t\t( type === 'br' &&\n\t\t\t\t\t! node.getAttribute( 'data-rich-text-line-break' ) ) )\n\t\t) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tcontinue;\n\t\t}\n\n\t\tif ( type === 'br' ) {\n\t\t\taccumulateSelection( accumulator, node, range, createEmptyValue() );\n\t\t\tmergePair( accumulator, create( { text: '\\n' } ) );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst lastFormats =\n\t\t\taccumulator.formats[ accumulator.formats.length - 1 ];\n\t\tconst lastFormat = lastFormats && lastFormats[ lastFormats.length - 1 ];\n\t\tconst newFormat = toFormat( {\n\t\t\ttype,\n\t\t\tattributes: getAttributes( { element: node } ),\n\t\t} );\n\t\tconst format = isFormatEqual( newFormat, lastFormat )\n\t\t\t? lastFormat\n\t\t\t: newFormat;\n\n\t\tif (\n\t\t\tmultilineWrapperTags &&\n\t\t\tmultilineWrapperTags.indexOf( type ) !== -1\n\t\t) {\n\t\t\tconst value = createFromMultilineElement( {\n\t\t\t\telement: node,\n\t\t\t\trange,\n\t\t\t\tmultilineTag,\n\t\t\t\tmultilineWrapperTags,\n\t\t\t\tcurrentWrapperTags: [ ...currentWrapperTags, format ],\n\t\t\t\tisEditableTree,\n\t\t\t\tpreserveWhiteSpace,\n\t\t\t} );\n\n\t\t\taccumulateSelection( accumulator, node, range, value );\n\t\t\tmergePair( accumulator, value );\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\n\t\tif ( ! format ) {\n\t\t\tmergePair( accumulator, value );\n\t\t} else if ( value.text.length === 0 ) {\n\t\t\tif ( format.attributes ) {\n\t\t\t\tmergePair( accumulator, {\n\t\t\t\t\tformats: [ , ],\n\t\t\t\t\treplacements: [ format ],\n\t\t\t\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t\t\t\t} );\n\t\t\t}\n\t\t} else {\n\t\t\t// Indices should share a reference to the same formats array.\n\t\t\t// Only create a new reference if `formats` changes.\n\t\t\tfunction mergeFormats( formats ) {\n\t\t\t\tif ( mergeFormats.formats === formats ) {\n\t\t\t\t\treturn mergeFormats.newFormats;\n\t\t\t\t}\n\n\t\t\t\tconst newFormats = formats\n\t\t\t\t\t? [ format, ...formats ]\n\t\t\t\t\t: [ format ];\n\n\t\t\t\tmergeFormats.formats = formats;\n\t\t\t\tmergeFormats.newFormats = newFormats;\n\n\t\t\t\treturn newFormats;\n\t\t\t}\n\n\t\t\t// Since the formats parameter can be `undefined`, preset\n\t\t\t// `mergeFormats` with a new reference.\n\t\t\tmergeFormats.newFormats = [ format ];\n\n\t\t\tmergePair( accumulator, {\n\t\t\t\t...value,\n\t\t\t\tformats: Array.from( value.formats, mergeFormats ),\n\t\t\t} );\n\t\t}\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Creates a rich text value from a DOM element and range that should be\n * multiline.\n *\n * @param {Object}  $1                        Named argements.\n * @param {Element} [$1.element]              Element to create value from.\n * @param {Range}   [$1.range]                Range to create value from.\n * @param {string}  [$1.multilineTag]         Multiline tag if the structure is\n *                                            multiline.\n * @param {Array}   [$1.multilineWrapperTags] Tags where lines can be found if\n *                                            nesting is possible.\n * @param {boolean} [$1.currentWrapperTags]   Whether to prepend a line\n *                                            separator.\n * @param {boolean} [$1.preserveWhiteSpace]   Whether or not to collapse white\n *                                            space characters.\n * @param {boolean} [$1.isEditableTree]\n *\n * @return {RichTextValue} A rich text value.\n */\nfunction createFromMultilineElement( {\n\telement,\n\trange,\n\tmultilineTag,\n\tmultilineWrapperTags,\n\tcurrentWrapperTags = [],\n\tisEditableTree,\n\tpreserveWhiteSpace,\n} ) {\n\tconst accumulator = createEmptyValue();\n\n\tif ( ! element || ! element.hasChildNodes() ) {\n\t\treturn accumulator;\n\t}\n\n\tconst length = element.children.length;\n\n\t// Optimise for speed.\n\tfor ( let index = 0; index < length; index++ ) {\n\t\tconst node = element.children[ index ];\n\n\t\tif ( node.nodeName.toLowerCase() !== multilineTag ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst value = createFromElement( {\n\t\t\telement: node,\n\t\t\trange,\n\t\t\tmultilineTag,\n\t\t\tmultilineWrapperTags,\n\t\t\tcurrentWrapperTags,\n\t\t\tisEditableTree,\n\t\t\tpreserveWhiteSpace,\n\t\t} );\n\n\t\t// Multiline value text should be separated by a line separator.\n\t\tif ( index !== 0 || currentWrapperTags.length > 0 ) {\n\t\t\tmergePair( accumulator, {\n\t\t\t\tformats: [ , ],\n\t\t\t\treplacements:\n\t\t\t\t\tcurrentWrapperTags.length > 0\n\t\t\t\t\t\t? [ currentWrapperTags ]\n\t\t\t\t\t\t: [ , ],\n\t\t\t\ttext: LINE_SEPARATOR,\n\t\t\t} );\n\t\t}\n\n\t\taccumulateSelection( accumulator, node, range, value );\n\t\tmergePair( accumulator, value );\n\t}\n\n\treturn accumulator;\n}\n\n/**\n * Gets the attributes of an element in object shape.\n *\n * @param {Object}  $1         Named argements.\n * @param {Element} $1.element Element to get attributes from.\n *\n * @return {Object|void} Attribute object or `undefined` if the element has no\n *                       attributes.\n */\nfunction getAttributes( { element } ) {\n\tif ( ! element.hasAttributes() ) {\n\t\treturn;\n\t}\n\n\tconst length = element.attributes.length;\n\tlet accumulator;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst { name, value } = element.attributes[ i ];\n\n\t\tif ( name.indexOf( 'data-rich-text-' ) === 0 ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\taccumulator = accumulator || {};\n\t\taccumulator[ name ] = value;\n\t}\n\n\treturn accumulator;\n}\n","/**\n * External dependencies\n */\n\nimport { find } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the format object by type at the start of the selection. This can be\n * used to get e.g. the URL of a link format at the current selection, but also\n * to check if a format is active at the selection. Returns undefined if there\n * is no format at the selection.\n *\n * @param {RichTextValue} value      Value to inspect.\n * @param {string}        formatType Format type to look for.\n *\n * @return {RichTextFormat|undefined} Active format object of the specified\n *                                    type, or undefined.\n */\nexport function getActiveFormat( value, formatType ) {\n\treturn find( getActiveFormats( value ), { type: formatType } );\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormatList} RichTextFormatList */\n\n/**\n * Gets the all format objects at the start of the selection.\n *\n * @param {RichTextValue} value                Value to inspect.\n * @param {Array}         EMPTY_ACTIVE_FORMATS Array to return if there are no\n *                                             active formats.\n *\n * @return {RichTextFormatList} Active format objects.\n */\nexport function getActiveFormats(\n\t{ formats, start, end, activeFormats },\n\tEMPTY_ACTIVE_FORMATS = []\n) {\n\tif ( start === undefined ) {\n\t\treturn EMPTY_ACTIVE_FORMATS;\n\t}\n\n\tif ( start === end ) {\n\t\t// For a collapsed caret, it is possible to override the active formats.\n\t\tif ( activeFormats ) {\n\t\t\treturn activeFormats;\n\t\t}\n\n\t\tconst formatsBefore = formats[ start - 1 ] || EMPTY_ACTIVE_FORMATS;\n\t\tconst formatsAfter = formats[ start ] || EMPTY_ACTIVE_FORMATS;\n\n\t\t// By default, select the lowest amount of formats possible (which means\n\t\t// the caret is positioned outside the format boundary). The user can\n\t\t// then use arrow keys to define `activeFormats`.\n\t\tif ( formatsBefore.length < formatsAfter.length ) {\n\t\t\treturn formatsBefore;\n\t\t}\n\n\t\treturn formatsAfter;\n\t}\n\n\treturn formats[ start ] || EMPTY_ACTIVE_FORMATS;\n}\n","/**\n * Internal dependencies\n */\n\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the active object, if there is any.\n *\n * @param {RichTextValue} value Value to inspect.\n *\n * @return {RichTextFormat|void} Active object, or undefined.\n */\nexport function getActiveObject( { start, end, replacements, text } ) {\n\tif ( start + 1 !== end || text[ start ] !== OBJECT_REPLACEMENT_CHARACTER ) {\n\t\treturn;\n\t}\n\n\treturn replacements[ start ];\n}\n","/**\n * WordPress dependencies\n */\nimport { select } from '@wordpress/data';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Returns a registered format type.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} Format type.\n */\nexport function getFormatType( name ) {\n\treturn select( 'core/rich-text' ).getFormatType( name );\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the line index of the last child in the list.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of a list item in the list.\n *\n * @return {number} The index of the last child.\n */\nexport function getLastChildIndex( { text, replacements }, lineIndex ) {\n\tconst lineFormats = replacements[ lineIndex ] || [];\n\t// Use the given line index in case there are no next children.\n\tlet childIndex = lineIndex;\n\n\t// `lineIndex` could be `undefined` if it's the first line.\n\tfor ( let index = lineIndex || 0; index < text.length; index++ ) {\n\t\t// We're only interested in line indices.\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// If the amout of formats is equal or more, store it, then return the\n\t\t// last one if the amount of formats is less.\n\t\tif ( formatsAtIndex.length >= lineFormats.length ) {\n\t\t\tchildIndex = index;\n\t\t} else {\n\t\t\treturn childIndex;\n\t\t}\n\t}\n\n\t// If the end of the text is reached, return the last child index.\n\treturn childIndex;\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the currently selected line index, or the first line index if the\n * selection spans over multiple items.\n *\n * @param {RichTextValue}  value      Value to get the line index from.\n * @param {boolean}        startIndex Optional index that should be contained by\n *                                    the line. Defaults to the selection start\n *                                    of the value.\n *\n * @return {number|void} The line index. Undefined if not found.\n */\nexport function getLineIndex( { start, text }, startIndex = start ) {\n\tlet index = startIndex;\n\n\twhile ( index-- ) {\n\t\tif ( text[ index ] === LINE_SEPARATOR ) {\n\t\t\treturn index;\n\t\t}\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Gets the index of the first parent list. To get the parent list formats, we\n * go through every list item until we find one with exactly one format type\n * less.\n *\n * @param {RichTextValue} value     Value to search.\n * @param {number}        lineIndex Line index of a child list item.\n *\n * @return {number|void} The parent list line index.\n */\nexport function getParentLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\tif ( formatsAtIndex.length === startFormats.length - 1 ) {\n\t\t\treturn index;\n\t\t}\n\t}\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Get the textual content of a Rich Text value. This is similar to\n * `Element.textContent`.\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {string} The text content.\n */\nexport function getTextContent( { text } ) {\n\treturn text;\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { canIndentListItems } from './can-indent-list-items';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Gets the line index of the first previous list item with higher indentation.\n *\n * @param {RichTextValue} value      Value to search.\n * @param {number}        lineIndex  Line index of the list item to compare\n *                                   with.\n *\n * @return {number|void} The line index.\n */\nfunction getTargetLevelLineIndex( { text, replacements }, lineIndex ) {\n\tconst startFormats = replacements[ lineIndex ] || [];\n\n\tlet index = lineIndex;\n\n\twhile ( index-- >= 0 ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst formatsAtIndex = replacements[ index ] || [];\n\n\t\t// Return the first line index that is one level higher. If the level is\n\t\t// lower or equal, there is no result.\n\t\tif ( formatsAtIndex.length === startFormats.length + 1 ) {\n\t\t\treturn index;\n\t\t} else if ( formatsAtIndex.length <= startFormats.length ) {\n\t\t\treturn;\n\t\t}\n\t}\n}\n\n/**\n * Indents any selected list items if possible.\n *\n * @param {RichTextValue}  value      Value to change.\n * @param {RichTextFormat} rootFormat Root format.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function indentListItems( value, rootFormat ) {\n\tif ( ! canIndentListItems( value ) ) {\n\t\treturn value;\n\t}\n\n\tconst lineIndex = getLineIndex( value );\n\tconst previousLineIndex = getLineIndex( value, lineIndex );\n\tconst { text, replacements, end } = value;\n\tconst newFormats = replacements.slice();\n\tconst targetLevelLineIndex = getTargetLevelLineIndex( value, lineIndex );\n\n\tfor ( let index = lineIndex; index < end; index++ ) {\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// Get the previous list, and if there's a child list, take over the\n\t\t// formats. If not, duplicate the last level and create a new level.\n\t\tif ( targetLevelLineIndex ) {\n\t\t\tconst targetFormats = replacements[ targetLevelLineIndex ] || [];\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length - 1 )\n\t\t\t);\n\t\t} else {\n\t\t\tconst targetFormats = replacements[ previousLineIndex ] || [];\n\t\t\tconst lastformat =\n\t\t\t\ttargetFormats[ targetFormats.length - 1 ] || rootFormat;\n\n\t\t\tnewFormats[ index ] = targetFormats.concat(\n\t\t\t\t[ lastformat ],\n\t\t\t\t( newFormats[ index ] || [] ).slice( targetFormats.length )\n\t\t\t);\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n","/**\n * Internal dependencies\n */\nimport './store';\n\nexport { applyFormat } from './apply-format';\nexport { concat } from './concat';\nexport { create } from './create';\nexport { getActiveFormat } from './get-active-format';\nexport { getActiveObject } from './get-active-object';\nexport { getTextContent } from './get-text-content';\nexport { isListRootSelected as __unstableIsListRootSelected } from './is-list-root-selected';\nexport { isActiveListType as __unstableIsActiveListType } from './is-active-list-type';\nexport { isCollapsed } from './is-collapsed';\nexport { isEmpty, isEmptyLine as __unstableIsEmptyLine } from './is-empty';\nexport { join } from './join';\nexport { registerFormatType } from './register-format-type';\nexport { removeFormat } from './remove-format';\nexport { remove } from './remove';\nexport { replace } from './replace';\nexport { insert } from './insert';\nexport { insertLineSeparator as __unstableInsertLineSeparator } from './insert-line-separator';\nexport { removeLineSeparator as __unstableRemoveLineSeparator } from './remove-line-separator';\nexport { insertObject } from './insert-object';\nexport { slice } from './slice';\nexport { split } from './split';\nexport { toDom as __unstableToDom } from './to-dom';\nexport { toHTMLString } from './to-html-string';\nexport { toggleFormat } from './toggle-format';\nexport { LINE_SEPARATOR as __UNSTABLE_LINE_SEPARATOR } from './special-characters';\nexport { unregisterFormatType } from './unregister-format-type';\nexport { canIndentListItems as __unstableCanIndentListItems } from './can-indent-list-items';\nexport { canOutdentListItems as __unstableCanOutdentListItems } from './can-outdent-list-items';\nexport { indentListItems as __unstableIndentListItems } from './indent-list-items';\nexport { outdentListItems as __unstableOutdentListItems } from './outdent-list-items';\nexport { changeListType as __unstableChangeListType } from './change-list-type';\nexport { createElement as __unstableCreateElement } from './create-element';\n\nexport { default as __experimentalRichText } from './component';\nexport { default as __unstableFormatEdit } from './component/format-edit';\n","/**\n * Internal dependencies\n */\n\nimport { getTextContent } from './get-text-content';\nimport { insert } from './insert';\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Insert a line break character into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insertLineSeparator(\n\tvalue,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst beforeText = getTextContent( value ).slice( 0, startIndex );\n\tconst previousLineSeparatorIndex = beforeText.lastIndexOf( LINE_SEPARATOR );\n\tconst previousLineSeparatorFormats =\n\t\tvalue.replacements[ previousLineSeparatorIndex ];\n\tlet replacements = [ , ];\n\n\tif ( previousLineSeparatorFormats ) {\n\t\treplacements = [ previousLineSeparatorFormats ];\n\t}\n\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements,\n\t\ttext: LINE_SEPARATOR,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { OBJECT_REPLACEMENT_CHARACTER } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Insert a format as an object into a Rich Text value at the given\n * `startIndex`. Any content between `startIndex` and `endIndex` will be\n * removed. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue}  value          Value to modify.\n * @param {RichTextFormat} formatToInsert Format to insert as object.\n * @param {number}         [startIndex]   Start index.\n * @param {number}         [endIndex]     End index.\n *\n * @return {RichTextValue} A new value with the object inserted.\n */\nexport function insertObject( value, formatToInsert, startIndex, endIndex ) {\n\tconst valueToInsert = {\n\t\tformats: [ , ],\n\t\treplacements: [ formatToInsert ],\n\t\ttext: OBJECT_REPLACEMENT_CHARACTER,\n\t};\n\n\treturn insert( value, valueToInsert, startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Insert a Rich Text value, an HTML string, or a plain text string, into a\n * Rich Text value at the given `startIndex`. Any content between `startIndex`\n * and `endIndex` will be removed. Indices are retrieved from the selection if\n * none are provided.\n *\n * @param {RichTextValue}        value         Value to modify.\n * @param {RichTextValue|string} valueToInsert Value to insert.\n * @param {number}               [startIndex]  Start index.\n * @param {number}               [endIndex]    End index.\n *\n * @return {RichTextValue} A new value with the value inserted.\n */\nexport function insert(\n\tvalue,\n\tvalueToInsert,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( typeof valueToInsert === 'string' ) {\n\t\tvalueToInsert = create( { text: valueToInsert } );\n\t}\n\n\tconst index = startIndex + valueToInsert.text.length;\n\n\treturn normaliseFormats( {\n\t\tformats: formats\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat( valueToInsert.formats, formats.slice( endIndex ) ),\n\t\treplacements: replacements\n\t\t\t.slice( 0, startIndex )\n\t\t\t.concat(\n\t\t\t\tvalueToInsert.replacements,\n\t\t\t\treplacements.slice( endIndex )\n\t\t\t),\n\t\ttext:\n\t\t\ttext.slice( 0, startIndex ) +\n\t\t\tvalueToInsert.text +\n\t\t\ttext.slice( endIndex ),\n\t\tstart: index,\n\t\tend: index,\n\t} );\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Wether or not the selected list has the given tag name.\n *\n * @param {RichTextValue} value    The value to check.\n * @param {string}        type     The tag name the list should have.\n * @param {string}        rootType The current root tag name, to compare with in\n *                                 case nothing is selected.\n *\n * @return {boolean} True if the current list type matches `type`, false if not.\n */\nexport function isActiveListType( value, type, rootType ) {\n\tconst { replacements, start } = value;\n\tconst lineIndex = getLineIndex( value, start );\n\tconst replacement = replacements[ lineIndex ];\n\n\tif ( ! replacement || replacement.length === 0 ) {\n\t\treturn type === rootType;\n\t}\n\n\tconst lastFormat = replacement[ replacement.length - 1 ];\n\n\treturn lastFormat.type === type;\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Check if the selection of a Rich Text value is collapsed or not. Collapsed\n * means that no characters are selected, but there is a caret present. If there\n * is no selection, `undefined` will be returned. This is similar to\n * `window.getSelection().isCollapsed()`.\n *\n * @param {RichTextValue} value The rich text value to check.\n *\n * @return {boolean|undefined} True if the selection is collapsed, false if not,\n *                             undefined if there is no selection.\n */\nexport function isCollapsed( { start, end } ) {\n\tif ( start === undefined || end === undefined ) {\n\t\treturn;\n\t}\n\n\treturn start === end;\n}\n","/**\n * Internal dependencies\n */\nimport { LINE_SEPARATOR } from './special-characters';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Check if a Rich Text value is Empty, meaning it contains no text or any\n * objects (such as images).\n *\n * @param {RichTextValue} value Value to use.\n *\n * @return {boolean} True if the value is empty, false if not.\n */\nexport function isEmpty( { text } ) {\n\treturn text.length === 0;\n}\n\n/**\n * Check if the current collapsed selection is on an empty line in case of a\n * multiline value.\n *\n * @param  {RichTextValue} value Value te check.\n *\n * @return {boolean} True if the line is empty, false if not.\n */\nexport function isEmptyLine( { text, start, end } ) {\n\tif ( start !== end ) {\n\t\treturn false;\n\t}\n\n\tif ( text.length === 0 ) {\n\t\treturn true;\n\t}\n\n\tif ( start === 0 && text.slice( 0, 1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\tif ( start === text.length && text.slice( -1 ) === LINE_SEPARATOR ) {\n\t\treturn true;\n\t}\n\n\treturn (\n\t\ttext.slice( start - 1, end + 1 ) ===\n\t\t`${ LINE_SEPARATOR }${ LINE_SEPARATOR }`\n\t);\n}\n","/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Optimised equality check for format objects.\n *\n * @param {?RichTextFormat} format1 Format to compare.\n * @param {?RichTextFormat} format2 Format to compare.\n *\n * @return {boolean} True if formats are equal, false if not.\n */\nexport function isFormatEqual( format1, format2 ) {\n\t// Both not defined.\n\tif ( format1 === format2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! format1 || ! format2 ) {\n\t\treturn false;\n\t}\n\n\tif ( format1.type !== format2.type ) {\n\t\treturn false;\n\t}\n\n\tconst attributes1 = format1.attributes;\n\tconst attributes2 = format2.attributes;\n\n\t// Both not defined.\n\tif ( attributes1 === attributes2 ) {\n\t\treturn true;\n\t}\n\n\t// Either not defined.\n\tif ( ! attributes1 || ! attributes2 ) {\n\t\treturn false;\n\t}\n\n\tconst keys1 = Object.keys( attributes1 );\n\tconst keys2 = Object.keys( attributes2 );\n\n\tif ( keys1.length !== keys2.length ) {\n\t\treturn false;\n\t}\n\n\tconst length = keys1.length;\n\n\t// Optimise for speed.\n\tfor ( let i = 0; i < length; i++ ) {\n\t\tconst name = keys1[ i ];\n\n\t\tif ( attributes1[ name ] !== attributes2[ name ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getLineIndex } from './get-line-index';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Whether or not the root list is selected.\n *\n * @param {RichTextValue} value The value to check.\n *\n * @return {boolean} True if the root list or nothing is selected, false if an\n *                   inner list is selected.\n */\nexport function isListRootSelected( value ) {\n\tconst { replacements, start } = value;\n\tconst lineIndex = getLineIndex( value, start );\n\tconst replacement = replacements[ lineIndex ];\n\n\treturn ! replacement || replacement.length < 1;\n}\n","/**\n * Internal dependencies\n */\n\nimport { create } from './create';\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Combine an array of Rich Text values into one, optionally separated by\n * `separator`, which can be a Rich Text value, HTML string, or plain text\n * string. This is similar to `Array.prototype.join`.\n *\n * @param {Array<RichTextValue>} values      An array of values to join.\n * @param {string|RichTextValue} [separator] Separator string or value.\n *\n * @return {RichTextValue} A new combined value.\n */\nexport function join( values, separator = '' ) {\n\tif ( typeof separator === 'string' ) {\n\t\tseparator = create( { text: separator } );\n\t}\n\n\treturn normaliseFormats(\n\t\tvalues.reduce( ( accumlator, { formats, replacements, text } ) => ( {\n\t\t\tformats: accumlator.formats.concat( separator.formats, formats ),\n\t\t\treplacements: accumlator.replacements.concat(\n\t\t\t\tseparator.replacements,\n\t\t\t\treplacements\n\t\t\t),\n\t\t\ttext: accumlator.text + separator.text + text,\n\t\t} ) )\n\t);\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Normalises formats: ensures subsequent adjacent equal formats have the same\n * reference.\n *\n * @param {RichTextValue} value Value to normalise formats of.\n *\n * @return {RichTextValue} New value with normalised formats.\n */\nexport function normaliseFormats( value ) {\n\tconst newFormats = value.formats.slice();\n\n\tnewFormats.forEach( ( formatsAtIndex, index ) => {\n\t\tconst formatsAtPreviousIndex = newFormats[ index - 1 ];\n\n\t\tif ( formatsAtPreviousIndex ) {\n\t\t\tconst newFormatsAtIndex = formatsAtIndex.slice();\n\n\t\t\tnewFormatsAtIndex.forEach( ( format, formatIndex ) => {\n\t\t\t\tconst previousFormat = formatsAtPreviousIndex[ formatIndex ];\n\n\t\t\t\tif ( isFormatEqual( format, previousFormat ) ) {\n\t\t\t\t\tnewFormatsAtIndex[ formatIndex ] = previousFormat;\n\t\t\t\t}\n\t\t\t} );\n\n\t\t\tnewFormats[ index ] = newFormatsAtIndex;\n\t\t}\n\t} );\n\n\treturn {\n\t\t...value,\n\t\tformats: newFormats,\n\t};\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { getLineIndex } from './get-line-index';\nimport { getParentLineIndex } from './get-parent-line-index';\nimport { getLastChildIndex } from './get-last-child-index';\nimport { canOutdentListItems } from './can-outdent-list-items';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Outdents any selected list items if possible.\n *\n * @param {RichTextValue} value Value to change.\n *\n * @return {RichTextValue} The changed value.\n */\nexport function outdentListItems( value ) {\n\tif ( ! canOutdentListItems( value ) ) {\n\t\treturn value;\n\t}\n\n\tconst { text, replacements, start, end } = value;\n\tconst startingLineIndex = getLineIndex( value, start );\n\tconst newFormats = replacements.slice( 0 );\n\tconst parentFormats =\n\t\treplacements[ getParentLineIndex( value, startingLineIndex ) ] || [];\n\tconst endingLineIndex = getLineIndex( value, end );\n\tconst lastChildIndex = getLastChildIndex( value, endingLineIndex );\n\n\t// Outdent all list items from the starting line index until the last child\n\t// index of the ending list. All children of the ending list need to be\n\t// outdented, otherwise they'll be orphaned.\n\tfor ( let index = startingLineIndex; index <= lastChildIndex; index++ ) {\n\t\t// Skip indices that are not line separators.\n\t\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\t// In the case of level 0, the formats at the index are undefined.\n\t\tconst currentFormats = newFormats[ index ] || [];\n\n\t\t// Omit the indentation level where the selection starts.\n\t\tnewFormats[ index ] = parentFormats.concat(\n\t\t\tcurrentFormats.slice( parentFormats.length + 1 )\n\t\t);\n\n\t\tif ( newFormats[ index ].length === 0 ) {\n\t\t\tdelete newFormats[ index ];\n\t\t}\n\t}\n\n\treturn {\n\t\t...value,\n\t\treplacements: newFormats,\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/**\n * @typedef {Object} WPFormat\n *\n * @property {string}   name        A string identifying the format. Must be\n *                                  unique across all registered formats.\n * @property {string}   tagName     The HTML tag this format will wrap the\n *                                  selection with.\n * @property {string}   [className] A class to match the format.\n * @property {string}   title       Name of the format.\n * @property {Function} edit        Should return a component for the user to\n *                                  interact with the new registered format.\n */\n\n/**\n * Registers a new format provided a unique name and an object defining its\n * behavior.\n *\n * @param {string}   name                 Format name.\n * @param {WPFormat} settings             Format settings.\n *\n * @return {WPFormat|undefined} The format, if it has been successfully\n *                              registered; otherwise `undefined`.\n */\nexport function registerFormatType( name, settings ) {\n\tsettings = {\n\t\tname,\n\t\t...settings,\n\t};\n\n\tif ( typeof settings.name !== 'string' ) {\n\t\twindow.console.error( 'Format names must be strings.' );\n\t\treturn;\n\t}\n\n\tif ( ! /^[a-z][a-z0-9-]*\\/[a-z][a-z0-9-]*$/.test( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format names must contain a namespace prefix, include only lowercase alphanumeric characters or dashes, and start with a letter. Example: my-plugin/my-custom-format'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( select( 'core/rich-text' ).getFormatType( settings.name ) ) {\n\t\twindow.console.error(\n\t\t\t'Format \"' + settings.name + '\" is already registered.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.tagName !== 'string' || settings.tagName === '' ) {\n\t\twindow.console.error( 'Format tag names must be a string.' );\n\t\treturn;\n\t}\n\n\tif (\n\t\t( typeof settings.className !== 'string' ||\n\t\t\tsettings.className === '' ) &&\n\t\tsettings.className !== null\n\t) {\n\t\twindow.console.error(\n\t\t\t'Format class names must be a string, or null to handle bare elements.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( ! /^[_a-zA-Z]+[a-zA-Z0-9-]*$/.test( settings.className ) ) {\n\t\twindow.console.error(\n\t\t\t'A class name must begin with a letter, followed by any number of hyphens, letters, or numbers.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( settings.className === null ) {\n\t\tconst formatTypeForBareElement = select(\n\t\t\t'core/rich-text'\n\t\t).getFormatTypeForBareElement( settings.tagName );\n\n\t\tif ( formatTypeForBareElement ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForBareElement.name }\" is already registered to handle bare tag name \"${ settings.tagName }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t} else {\n\t\tconst formatTypeForClassName = select(\n\t\t\t'core/rich-text'\n\t\t).getFormatTypeForClassName( settings.className );\n\n\t\tif ( formatTypeForClassName ) {\n\t\t\twindow.console.error(\n\t\t\t\t`Format \"${ formatTypeForClassName.name }\" is already registered to handle class name \"${ settings.className }\".`\n\t\t\t);\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif ( ! ( 'title' in settings ) || settings.title === '' ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' + settings.name + '\" must have a title.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( 'keywords' in settings && settings.keywords.length > 3 ) {\n\t\twindow.console.error(\n\t\t\t'The format \"' +\n\t\t\t\tsettings.name +\n\t\t\t\t'\" can have a maximum of 3 keywords.'\n\t\t);\n\t\treturn;\n\t}\n\n\tif ( typeof settings.title !== 'string' ) {\n\t\twindow.console.error( 'Format titles must be strings.' );\n\t\treturn;\n\t}\n\n\tdispatch( 'core/rich-text' ).addFormatTypes( settings );\n\n\treturn settings;\n}\n","/**\n * External dependencies\n */\n\nimport { find, reject } from 'lodash';\n\n/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Remove any format object from a Rich Text value by type from the given\n * `startIndex` to the given `endIndex`. Indices are retrieved from the\n * selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {string}        formatType   Format type to remove.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the format applied.\n */\nexport function removeFormat(\n\tvalue,\n\tformatType,\n\tstartIndex = value.start,\n\tendIndex = value.end\n) {\n\tconst { formats, activeFormats } = value;\n\tconst newFormats = formats.slice();\n\n\t// If the selection is collapsed, expand start and end to the edges of the\n\t// format.\n\tif ( startIndex === endIndex ) {\n\t\tconst format = find( newFormats[ startIndex ], { type: formatType } );\n\n\t\tif ( format ) {\n\t\t\twhile ( find( newFormats[ startIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, startIndex, formatType );\n\t\t\t\tstartIndex--;\n\t\t\t}\n\n\t\t\tendIndex++;\n\n\t\t\twhile ( find( newFormats[ endIndex ], format ) ) {\n\t\t\t\tfilterFormats( newFormats, endIndex, formatType );\n\t\t\t\tendIndex++;\n\t\t\t}\n\t\t}\n\t} else {\n\t\tfor ( let i = startIndex; i < endIndex; i++ ) {\n\t\t\tif ( newFormats[ i ] ) {\n\t\t\t\tfilterFormats( newFormats, i, formatType );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn normaliseFormats( {\n\t\t...value,\n\t\tformats: newFormats,\n\t\tactiveFormats: reject( activeFormats, { type: formatType } ),\n\t} );\n}\n\nfunction filterFormats( formats, index, formatType ) {\n\tconst newFormats = formats[ index ].filter(\n\t\t( { type } ) => type !== formatType\n\t);\n\n\tif ( newFormats.length ) {\n\t\tformats[ index ] = newFormats;\n\t} else {\n\t\tdelete formats[ index ];\n\t}\n}\n","/**\n * Internal dependencies\n */\n\nimport { LINE_SEPARATOR } from './special-characters';\nimport { isCollapsed } from './is-collapsed';\nimport { remove } from './remove';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Removes a line separator character, if existing, from a Rich Text value at\n * the current indices. If no line separator exists on the indices it will\n * return undefined.\n *\n * @param {RichTextValue} value    Value to modify.\n * @param {boolean}       backward Indicates if are removing from the start\n *                                 index or the end index.\n *\n * @return {RichTextValue|undefined} A new value with the line separator\n *                                   removed. Or undefined if no line separator\n *                                   is found on the position.\n */\nexport function removeLineSeparator( value, backward = true ) {\n\tconst { replacements, text, start, end } = value;\n\tconst collapsed = isCollapsed( value );\n\tlet index = start - 1;\n\tlet removeStart = collapsed ? start - 1 : start;\n\tlet removeEnd = end;\n\tif ( ! backward ) {\n\t\tindex = end;\n\t\tremoveStart = start;\n\t\tremoveEnd = collapsed ? end + 1 : end;\n\t}\n\n\tif ( text[ index ] !== LINE_SEPARATOR ) {\n\t\treturn;\n\t}\n\n\tlet newValue;\n\t// If the line separator that is about te be removed\n\t// contains wrappers, remove the wrappers first.\n\tif ( collapsed && replacements[ index ] && replacements[ index ].length ) {\n\t\tconst newReplacements = replacements.slice();\n\n\t\tnewReplacements[ index ] = replacements[ index ].slice( 0, -1 );\n\t\tnewValue = {\n\t\t\t...value,\n\t\t\treplacements: newReplacements,\n\t\t};\n\t} else {\n\t\tnewValue = remove( value, removeStart, removeEnd );\n\t}\n\treturn newValue;\n}\n","/**\n * Internal dependencies\n */\n\nimport { insert } from './insert';\nimport { create } from './create';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Remove content from a Rich Text value between the given `startIndex` and\n * `endIndex`. Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new value with the content removed.\n */\nexport function remove( value, startIndex, endIndex ) {\n\treturn insert( value, create(), startIndex, endIndex );\n}\n","/**\n * Internal dependencies\n */\n\nimport { normaliseFormats } from './normalise-formats';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Search a Rich Text value and replace the match(es) with `replacement`. This\n * is similar to `String.prototype.replace`.\n *\n * @param {RichTextValue}  value        The value to modify.\n * @param {RegExp|string}  pattern      A RegExp object or literal. Can also be\n *                                      a string. It is treated as a verbatim\n *                                      string and is not interpreted as a\n *                                      regular expression. Only the first\n *                                      occurrence will be replaced.\n * @param {Function|string} replacement The match or matches are replaced with\n *                                      the specified or the value returned by\n *                                      the specified function.\n *\n * @return {RichTextValue} A new value with replacements applied.\n */\nexport function replace(\n\t{ formats, replacements, text, start, end },\n\tpattern,\n\treplacement\n) {\n\ttext = text.replace( pattern, ( match, ...rest ) => {\n\t\tconst offset = rest[ rest.length - 2 ];\n\t\tlet newText = replacement;\n\t\tlet newFormats;\n\t\tlet newReplacements;\n\n\t\tif ( typeof newText === 'function' ) {\n\t\t\tnewText = replacement( match, ...rest );\n\t\t}\n\n\t\tif ( typeof newText === 'object' ) {\n\t\t\tnewFormats = newText.formats;\n\t\t\tnewReplacements = newText.replacements;\n\t\t\tnewText = newText.text;\n\t\t} else {\n\t\t\tnewFormats = Array( newText.length );\n\t\t\tnewReplacements = Array( newText.length );\n\n\t\t\tif ( formats[ offset ] ) {\n\t\t\t\tnewFormats = newFormats.fill( formats[ offset ] );\n\t\t\t}\n\t\t}\n\n\t\tformats = formats\n\t\t\t.slice( 0, offset )\n\t\t\t.concat( newFormats, formats.slice( offset + match.length ) );\n\t\treplacements = replacements\n\t\t\t.slice( 0, offset )\n\t\t\t.concat(\n\t\t\t\tnewReplacements,\n\t\t\t\treplacements.slice( offset + match.length )\n\t\t\t);\n\n\t\tif ( start ) {\n\t\t\tstart = end = offset + newText.length;\n\t\t}\n\n\t\treturn newText;\n\t} );\n\n\treturn normaliseFormats( { formats, replacements, text, start, end } );\n}\n","/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Slice a Rich Text value from `startIndex` to `endIndex`. Indices are\n * retrieved from the selection if none are provided. This is similar to\n * `String.prototype.slice`.\n *\n * @param {RichTextValue} value        Value to modify.\n * @param {number}        [startIndex] Start index.\n * @param {number}        [endIndex]   End index.\n *\n * @return {RichTextValue} A new extracted value.\n */\nexport function slice( value, startIndex = value.start, endIndex = value.end ) {\n\tconst { formats, replacements, text } = value;\n\n\tif ( startIndex === undefined || endIndex === undefined ) {\n\t\treturn { ...value };\n\t}\n\n\treturn {\n\t\tformats: formats.slice( startIndex, endIndex ),\n\t\treplacements: replacements.slice( startIndex, endIndex ),\n\t\ttext: text.slice( startIndex, endIndex ),\n\t};\n}\n","/**\n * Line separator character, used for multiline text.\n */\nexport const LINE_SEPARATOR = '\\u2028';\n\n/**\n * Object replacement character, used as a placeholder for objects.\n */\nexport const OBJECT_REPLACEMENT_CHARACTER = '\\ufffc';\n\n/**\n * Zero width non-breaking space, used as padding in the editable DOM tree when\n * it is empty otherwise.\n */\nexport const ZWNBSP = '\\ufeff';\n","/**\n * Internal dependencies\n */\n\nimport { replace } from './replace';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Split a Rich Text value in two at the given `startIndex` and `endIndex`, or\n * split at the given separator. This is similar to `String.prototype.split`.\n * Indices are retrieved from the selection if none are provided.\n *\n * @param {RichTextValue} value\n * @param {number|string} [string] Start index, or string at which to split.\n *\n * @return {Array<RichTextValue>} An array of new values.\n */\nexport function split( { formats, replacements, text, start, end }, string ) {\n\tif ( typeof string !== 'string' ) {\n\t\treturn splitAtSelection( ...arguments );\n\t}\n\n\tlet nextStart = 0;\n\n\treturn text.split( string ).map( ( substring ) => {\n\t\tconst startIndex = nextStart;\n\t\tconst value = {\n\t\t\tformats: formats.slice( startIndex, startIndex + substring.length ),\n\t\t\treplacements: replacements.slice(\n\t\t\t\tstartIndex,\n\t\t\t\tstartIndex + substring.length\n\t\t\t),\n\t\t\ttext: substring,\n\t\t};\n\n\t\tnextStart += string.length + substring.length;\n\n\t\tif ( start !== undefined && end !== undefined ) {\n\t\t\tif ( start >= startIndex && start < nextStart ) {\n\t\t\t\tvalue.start = start - startIndex;\n\t\t\t} else if ( start < startIndex && end > startIndex ) {\n\t\t\t\tvalue.start = 0;\n\t\t\t}\n\n\t\t\tif ( end >= startIndex && end < nextStart ) {\n\t\t\t\tvalue.end = end - startIndex;\n\t\t\t} else if ( start < nextStart && end > nextStart ) {\n\t\t\t\tvalue.end = substring.length;\n\t\t\t}\n\t\t}\n\n\t\treturn value;\n\t} );\n}\n\nfunction splitAtSelection(\n\t{ formats, replacements, text, start, end },\n\tstartIndex = start,\n\tendIndex = end\n) {\n\tconst before = {\n\t\tformats: formats.slice( 0, startIndex ),\n\t\treplacements: replacements.slice( 0, startIndex ),\n\t\ttext: text.slice( 0, startIndex ),\n\t};\n\tconst after = {\n\t\tformats: formats.slice( endIndex ),\n\t\treplacements: replacements.slice( endIndex ),\n\t\ttext: text.slice( endIndex ),\n\t\tstart: 0,\n\t\tend: 0,\n\t};\n\n\treturn [\n\t\t// Ensure newlines are trimmed.\n\t\treplace( before, /\\u2028+$/, '' ),\n\t\treplace( after, /^\\u2028+/, '' ),\n\t];\n}\n","/**\n * External dependencies\n */\nimport { castArray } from 'lodash';\n\n/**\n * Returns an action object used in signalling that format types have been\n * added.\n *\n * @param {Array|Object} formatTypes Format types received.\n *\n * @return {Object} Action object.\n */\nexport function addFormatTypes( formatTypes ) {\n\treturn {\n\t\ttype: 'ADD_FORMAT_TYPES',\n\t\tformatTypes: castArray( formatTypes ),\n\t};\n}\n\n/**\n * Returns an action object used to remove a registered format type.\n *\n * @param {string|Array} names Format name.\n *\n * @return {Object} Action object.\n */\nexport function removeFormatTypes( names ) {\n\treturn {\n\t\ttype: 'REMOVE_FORMAT_TYPES',\n\t\tnames: castArray( names ),\n\t};\n}\n","/**\n * WordPress dependencies\n */\nimport { registerStore } from '@wordpress/data';\n\n/**\n * Internal dependencies\n */\nimport reducer from './reducer';\nimport * as selectors from './selectors';\nimport * as actions from './actions';\n\nregisterStore( 'core/rich-text', { reducer, selectors, actions } );\n","/**\n * External dependencies\n */\nimport { keyBy, omit } from 'lodash';\n\n/**\n * WordPress dependencies\n */\nimport { combineReducers } from '@wordpress/data';\n\n/**\n * Reducer managing the format types\n *\n * @param {Object} state  Current state.\n * @param {Object} action Dispatched action.\n *\n * @return {Object} Updated state.\n */\nexport function formatTypes( state = {}, action ) {\n\tswitch ( action.type ) {\n\t\tcase 'ADD_FORMAT_TYPES':\n\t\t\treturn {\n\t\t\t\t...state,\n\t\t\t\t...keyBy( action.formatTypes, 'name' ),\n\t\t\t};\n\t\tcase 'REMOVE_FORMAT_TYPES':\n\t\t\treturn omit( state, action.names );\n\t}\n\n\treturn state;\n}\n\nexport default combineReducers( { formatTypes } );\n","/**\n * External dependencies\n */\nimport createSelector from 'rememo';\nimport { find } from 'lodash';\n\n/**\n * Returns all the available format types.\n *\n * @param {Object} state Data state.\n *\n * @return {Array} Format types.\n */\nexport const getFormatTypes = createSelector(\n\t( state ) => Object.values( state.formatTypes ),\n\t( state ) => [ state.formatTypes ]\n);\n\n/**\n * Returns a format type by name.\n *\n * @param {Object} state Data state.\n * @param {string} name Format type name.\n *\n * @return {Object?} Format type.\n */\nexport function getFormatType( state, name ) {\n\treturn state.formatTypes[ name ];\n}\n\n/**\n * Gets the format type, if any, that can handle a bare element (without a\n * data-format-type attribute), given the tag name of this element.\n *\n * @param {Object} state              Data state.\n * @param {string} bareElementTagName The tag name of the element to find a\n *                                    format type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForBareElement( state, bareElementTagName ) {\n\treturn find( getFormatTypes( state ), ( { className, tagName } ) => {\n\t\treturn className === null && bareElementTagName === tagName;\n\t} );\n}\n\n/**\n * Gets the format type, if any, that can handle an element, given its classes.\n *\n * @param {Object} state            Data state.\n * @param {string} elementClassName The classes of the element to find a format\n *                                  type for.\n * @return {?Object} Format type.\n */\nexport function getFormatTypeForClassName( state, elementClassName ) {\n\treturn find( getFormatTypes( state ), ( { className } ) => {\n\t\tif ( className === null ) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn ` ${ elementClassName } `.indexOf( ` ${ className } ` ) >= 0;\n\t} );\n}\n","/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\nimport { createElement } from './create-element';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Creates a path as an array of indices from the given root node to the given\n * node.\n *\n * @param {Node}        node     Node to find the path of.\n * @param {HTMLElement} rootNode Root node to find the path from.\n * @param {Array}       path     Initial path to build on.\n *\n * @return {Array} The path from the root node to the node.\n */\nfunction createPathToNode( node, rootNode, path ) {\n\tconst parentNode = node.parentNode;\n\tlet i = 0;\n\n\twhile ( ( node = node.previousSibling ) ) {\n\t\ti++;\n\t}\n\n\tpath = [ i, ...path ];\n\n\tif ( parentNode !== rootNode ) {\n\t\tpath = createPathToNode( parentNode, rootNode, path );\n\t}\n\n\treturn path;\n}\n\n/**\n * Gets a node given a path (array of indices) from the given node.\n *\n * @param {HTMLElement} node Root node to find the wanted node in.\n * @param {Array}       path Path (indices) to the wanted node.\n *\n * @return {Object} Object with the found node and the remaining offset (if any).\n */\nfunction getNodeByPath( node, path ) {\n\tpath = [ ...path ];\n\n\twhile ( node && path.length > 1 ) {\n\t\tnode = node.childNodes[ path.shift() ];\n\t}\n\n\treturn {\n\t\tnode,\n\t\toffset: path[ 0 ],\n\t};\n}\n\nfunction append( element, child ) {\n\tif ( typeof child === 'string' ) {\n\t\tchild = element.ownerDocument.createTextNode( child );\n\t}\n\n\tconst { type, attributes } = child;\n\n\tif ( type ) {\n\t\tchild = element.ownerDocument.createElement( type );\n\n\t\tfor ( const key in attributes ) {\n\t\t\tchild.setAttribute( key, attributes[ key ] );\n\t\t}\n\t}\n\n\treturn element.appendChild( child );\n}\n\nfunction appendText( node, text ) {\n\tnode.appendData( text );\n}\n\nfunction getLastChild( { lastChild } ) {\n\treturn lastChild;\n}\n\nfunction getParent( { parentNode } ) {\n\treturn parentNode;\n}\n\nfunction isText( node ) {\n\treturn node.nodeType === node.TEXT_NODE;\n}\n\nfunction getText( { nodeValue } ) {\n\treturn nodeValue;\n}\n\nfunction remove( node ) {\n\treturn node.parentNode.removeChild( node );\n}\n\nexport function toDom( {\n\tvalue,\n\tmultilineTag,\n\tprepareEditableTree,\n\tisEditableTree = true,\n\tplaceholder,\n\tdoc = document,\n} ) {\n\tlet startPath = [];\n\tlet endPath = [];\n\n\tif ( prepareEditableTree ) {\n\t\tvalue = {\n\t\t\t...value,\n\t\t\tformats: prepareEditableTree( value ),\n\t\t};\n\t}\n\n\t/**\n\t * Returns a new instance of a DOM tree upon which RichText operations can be\n\t * applied.\n\t *\n\t * Note: The current implementation will return a shared reference, reset on\n\t * each call to `createEmpty`. Therefore, you should not hold a reference to\n\t * the value to operate upon asynchronously, as it may have unexpected results.\n\t *\n\t * @return {Object} RichText tree.\n\t */\n\tconst createEmpty = () => createElement( doc, '' );\n\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t\tonStartIndex( body, pointer ) {\n\t\t\tstartPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tonEndIndex( body, pointer ) {\n\t\t\tendPath = createPathToNode( pointer, body, [\n\t\t\t\tpointer.nodeValue.length,\n\t\t\t] );\n\t\t},\n\t\tisEditableTree,\n\t\tplaceholder,\n\t} );\n\n\treturn {\n\t\tbody: tree,\n\t\tselection: { startPath, endPath },\n\t};\n}\n\n/**\n * Create an `Element` tree from a Rich Text value and applies the difference to\n * the `Element` tree contained by `current`. If a `multilineTag` is provided,\n * text separated by two new lines will be wrapped in an `Element` of that type.\n *\n * @param {Object}        $1                       Named arguments.\n * @param {RichTextValue} $1.value                 Value to apply.\n * @param {HTMLElement}   $1.current               The live root node to apply the element tree to.\n * @param {string}        [$1.multilineTag]        Multiline tag.\n * @param {Function}      [$1.prepareEditableTree] Function to filter editorable formats.\n * @param {boolean}       [$1.__unstableDomOnly]   Only apply elements, no selection.\n * @param {string}        [$1.placeholder]         Placeholder text.\n */\nexport function apply( {\n\tvalue,\n\tcurrent,\n\tmultilineTag,\n\tprepareEditableTree,\n\t__unstableDomOnly,\n\tplaceholder,\n} ) {\n\t// Construct a new element tree in memory.\n\tconst { body, selection } = toDom( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tprepareEditableTree,\n\t\tplaceholder,\n\t\tdoc: current.ownerDocument,\n\t} );\n\n\tapplyValue( body, current );\n\n\tif ( value.start !== undefined && ! __unstableDomOnly ) {\n\t\tapplySelection( selection, current );\n\t}\n}\n\nexport function applyValue( future, current ) {\n\tlet i = 0;\n\tlet futureChild;\n\n\twhile ( ( futureChild = future.firstChild ) ) {\n\t\tconst currentChild = current.childNodes[ i ];\n\n\t\tif ( ! currentChild ) {\n\t\t\tcurrent.appendChild( futureChild );\n\t\t} else if ( ! currentChild.isEqualNode( futureChild ) ) {\n\t\t\tif (\n\t\t\t\tcurrentChild.nodeName !== futureChild.nodeName ||\n\t\t\t\t( currentChild.nodeType === currentChild.TEXT_NODE &&\n\t\t\t\t\tcurrentChild.data !== futureChild.data )\n\t\t\t) {\n\t\t\t\tcurrent.replaceChild( futureChild, currentChild );\n\t\t\t} else {\n\t\t\t\tconst currentAttributes = currentChild.attributes;\n\t\t\t\tconst futureAttributes = futureChild.attributes;\n\n\t\t\t\tif ( currentAttributes ) {\n\t\t\t\t\tlet ii = currentAttributes.length;\n\n\t\t\t\t\t// Reverse loop because `removeAttribute` on `currentChild`\n\t\t\t\t\t// changes `currentAttributes`.\n\t\t\t\t\twhile ( ii-- ) {\n\t\t\t\t\t\tconst { name } = currentAttributes[ ii ];\n\n\t\t\t\t\t\tif ( ! futureChild.getAttribute( name ) ) {\n\t\t\t\t\t\t\tcurrentChild.removeAttribute( name );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( futureAttributes ) {\n\t\t\t\t\tfor ( let ii = 0; ii < futureAttributes.length; ii++ ) {\n\t\t\t\t\t\tconst { name, value } = futureAttributes[ ii ];\n\n\t\t\t\t\t\tif ( currentChild.getAttribute( name ) !== value ) {\n\t\t\t\t\t\t\tcurrentChild.setAttribute( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tapplyValue( futureChild, currentChild );\n\t\t\t\tfuture.removeChild( futureChild );\n\t\t\t}\n\t\t} else {\n\t\t\tfuture.removeChild( futureChild );\n\t\t}\n\n\t\ti++;\n\t}\n\n\twhile ( current.childNodes[ i ] ) {\n\t\tcurrent.removeChild( current.childNodes[ i ] );\n\t}\n}\n\n/**\n * Returns true if two ranges are equal, or false otherwise. Ranges are\n * considered equal if their start and end occur in the same container and\n * offset.\n *\n * @param {Range} a First range object to test.\n * @param {Range} b First range object to test.\n *\n * @return {boolean} Whether the two ranges are equal.\n */\nfunction isRangeEqual( a, b ) {\n\treturn (\n\t\ta.startContainer === b.startContainer &&\n\t\ta.startOffset === b.startOffset &&\n\t\ta.endContainer === b.endContainer &&\n\t\ta.endOffset === b.endOffset\n\t);\n}\n\nexport function applySelection( { startPath, endPath }, current ) {\n\tconst { node: startContainer, offset: startOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tstartPath\n\t);\n\tconst { node: endContainer, offset: endOffset } = getNodeByPath(\n\t\tcurrent,\n\t\tendPath\n\t);\n\tconst { ownerDocument } = current;\n\tconst { defaultView } = ownerDocument;\n\tconst selection = defaultView.getSelection();\n\tconst range = ownerDocument.createRange();\n\n\trange.setStart( startContainer, startOffset );\n\trange.setEnd( endContainer, endOffset );\n\n\tconst { activeElement } = ownerDocument;\n\n\tif ( selection.rangeCount > 0 ) {\n\t\t// If the to be added range and the live range are the same, there's no\n\t\t// need to remove the live range and add the equivalent range.\n\t\tif ( isRangeEqual( range, selection.getRangeAt( 0 ) ) ) {\n\t\t\treturn;\n\t\t}\n\n\t\tselection.removeAllRanges();\n\t}\n\n\tselection.addRange( range );\n\n\t// This function is not intended to cause a shift in focus. Since the above\n\t// selection manipulations may shift focus, ensure that focus is restored to\n\t// its previous state.\n\tif ( activeElement !== ownerDocument.activeElement ) {\n\t\t// The `instanceof` checks protect against edge cases where the focused\n\t\t// element is not of the interface HTMLElement (does not have a `focus`\n\t\t// or `blur` property).\n\t\t//\n\t\t// See: https://github.com/Microsoft/TypeScript/issues/5901#issuecomment-431649653\n\t\tif ( activeElement instanceof defaultView.HTMLElement ) {\n\t\t\tactiveElement.focus();\n\t\t}\n\t}\n}\n","/**\n * WordPress dependencies\n */\n\nimport {\n\tescapeEditableHTML,\n\tescapeAttribute,\n\tisValidAttributeName,\n} from '@wordpress/escape-html';\n\n/**\n * Internal dependencies\n */\n\nimport { toTree } from './to-tree';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Create an HTML string from a Rich Text value. If a `multilineTag` is\n * provided, text separated by a line separator will be wrapped in it.\n *\n * @param {Object}        $1                      Named argements.\n * @param {RichTextValue} $1.value                Rich text value.\n * @param {string}        [$1.multilineTag]       Multiline tag.\n * @param {boolean}       [$1.preserveWhiteSpace] Whether or not to use newline\n *                                                characters for line breaks.\n *\n * @return {string} HTML string.\n */\nexport function toHTMLString( { value, multilineTag, preserveWhiteSpace } ) {\n\tconst tree = toTree( {\n\t\tvalue,\n\t\tmultilineTag,\n\t\tpreserveWhiteSpace,\n\t\tcreateEmpty,\n\t\tappend,\n\t\tgetLastChild,\n\t\tgetParent,\n\t\tisText,\n\t\tgetText,\n\t\tremove,\n\t\tappendText,\n\t} );\n\n\treturn createChildrenHTML( tree.children );\n}\n\nfunction createEmpty() {\n\treturn {};\n}\n\nfunction getLastChild( { children } ) {\n\treturn children && children[ children.length - 1 ];\n}\n\nfunction append( parent, object ) {\n\tif ( typeof object === 'string' ) {\n\t\tobject = { text: object };\n\t}\n\n\tobject.parent = parent;\n\tparent.children = parent.children || [];\n\tparent.children.push( object );\n\treturn object;\n}\n\nfunction appendText( object, text ) {\n\tobject.text += text;\n}\n\nfunction getParent( { parent } ) {\n\treturn parent;\n}\n\nfunction isText( { text } ) {\n\treturn typeof text === 'string';\n}\n\nfunction getText( { text } ) {\n\treturn text;\n}\n\nfunction remove( object ) {\n\tconst index = object.parent.children.indexOf( object );\n\n\tif ( index !== -1 ) {\n\t\tobject.parent.children.splice( index, 1 );\n\t}\n\n\treturn object;\n}\n\nfunction createElementHTML( { type, attributes, object, children } ) {\n\tlet attributeString = '';\n\n\tfor ( const key in attributes ) {\n\t\tif ( ! isValidAttributeName( key ) ) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tattributeString += ` ${ key }=\"${ escapeAttribute(\n\t\t\tattributes[ key ]\n\t\t) }\"`;\n\t}\n\n\tif ( object ) {\n\t\treturn `<${ type }${ attributeString }>`;\n\t}\n\n\treturn `<${ type }${ attributeString }>${ createChildrenHTML(\n\t\tchildren\n\t) }</${ type }>`;\n}\n\nfunction createChildrenHTML( children = [] ) {\n\treturn children\n\t\t.map( ( child ) => {\n\t\t\treturn child.text === undefined\n\t\t\t\t? createElementHTML( child )\n\t\t\t\t: escapeEditableHTML( child.text );\n\t\t} )\n\t\t.join( '' );\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormats } from './get-active-formats';\nimport { getFormatType } from './get-format-type';\nimport {\n\tLINE_SEPARATOR,\n\tOBJECT_REPLACEMENT_CHARACTER,\n\tZWNBSP,\n} from './special-characters';\n\n/**\n * Converts a format object to information that can be used to create an element\n * from (type, attributes and object).\n *\n * @param  {Object}  $1                        Named parameters.\n * @param  {string}  $1.type                   The format type.\n * @param  {Object}  $1.attributes             The format attributes.\n * @param  {Object}  $1.unregisteredAttributes The unregistered format\n *                                             attributes.\n * @param  {boolean} $1.object                 Wether or not it is an object\n *                                             format.\n * @param  {boolean} $1.boundaryClass          Wether or not to apply a boundary\n *                                             class.\n * @return {Object}                            Information to be used for\n *                                             element creation.\n */\nfunction fromFormat( {\n\ttype,\n\tattributes,\n\tunregisteredAttributes,\n\tobject,\n\tboundaryClass,\n} ) {\n\tconst formatType = getFormatType( type );\n\n\tlet elementAttributes = {};\n\n\tif ( boundaryClass ) {\n\t\telementAttributes[ 'data-rich-text-format-boundary' ] = 'true';\n\t}\n\n\tif ( ! formatType ) {\n\t\tif ( attributes ) {\n\t\t\telementAttributes = { ...attributes, ...elementAttributes };\n\t\t}\n\n\t\treturn { type, attributes: elementAttributes, object };\n\t}\n\n\telementAttributes = { ...unregisteredAttributes, ...elementAttributes };\n\n\tfor ( const name in attributes ) {\n\t\tconst key = formatType.attributes\n\t\t\t? formatType.attributes[ name ]\n\t\t\t: false;\n\n\t\tif ( key ) {\n\t\t\telementAttributes[ key ] = attributes[ name ];\n\t\t} else {\n\t\t\telementAttributes[ name ] = attributes[ name ];\n\t\t}\n\t}\n\n\tif ( formatType.className ) {\n\t\tif ( elementAttributes.class ) {\n\t\t\telementAttributes.class = `${ formatType.className } ${ elementAttributes.class }`;\n\t\t} else {\n\t\t\telementAttributes.class = formatType.className;\n\t\t}\n\t}\n\n\treturn {\n\t\ttype: formatType.tagName,\n\t\tobject: formatType.object,\n\t\tattributes: elementAttributes,\n\t};\n}\n\n/**\n * Checks if both arrays of formats up until a certain index are equal.\n *\n * @param {Array}  a     Array of formats to compare.\n * @param {Array}  b     Array of formats to compare.\n * @param {number} index Index to check until.\n */\nfunction isEqualUntil( a, b, index ) {\n\tdo {\n\t\tif ( a[ index ] !== b[ index ] ) {\n\t\t\treturn false;\n\t\t}\n\t} while ( index-- );\n\n\treturn true;\n}\n\nexport function toTree( {\n\tvalue,\n\tmultilineTag,\n\tpreserveWhiteSpace,\n\tcreateEmpty,\n\tappend,\n\tgetLastChild,\n\tgetParent,\n\tisText,\n\tgetText,\n\tremove,\n\tappendText,\n\tonStartIndex,\n\tonEndIndex,\n\tisEditableTree,\n\tplaceholder,\n} ) {\n\tconst { formats, replacements, text, start, end } = value;\n\tconst formatsLength = formats.length + 1;\n\tconst tree = createEmpty();\n\tconst multilineFormat = { type: multilineTag };\n\tconst activeFormats = getActiveFormats( value );\n\tconst deepestActiveFormat = activeFormats[ activeFormats.length - 1 ];\n\n\tlet lastSeparatorFormats;\n\tlet lastCharacterFormats;\n\tlet lastCharacter;\n\n\t// If we're building a multiline tree, start off with a multiline element.\n\tif ( multilineTag ) {\n\t\tappend( append( tree, { type: multilineTag } ), '' );\n\t\tlastCharacterFormats = lastSeparatorFormats = [ multilineFormat ];\n\t} else {\n\t\tappend( tree, '' );\n\t}\n\n\tfor ( let i = 0; i < formatsLength; i++ ) {\n\t\tconst character = text.charAt( i );\n\t\tconst shouldInsertPadding =\n\t\t\tisEditableTree &&\n\t\t\t// Pad the line if the line is empty.\n\t\t\t( ! lastCharacter ||\n\t\t\t\tlastCharacter === LINE_SEPARATOR ||\n\t\t\t\t// Pad the line if the previous character is a line break, otherwise\n\t\t\t\t// the line break won't be visible.\n\t\t\t\tlastCharacter === '\\n' );\n\n\t\tlet characterFormats = formats[ i ];\n\n\t\t// Set multiline tags in queue for building the tree.\n\t\tif ( multilineTag ) {\n\t\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\t\tcharacterFormats = lastSeparatorFormats = (\n\t\t\t\t\treplacements[ i ] || []\n\t\t\t\t).reduce(\n\t\t\t\t\t( accumulator, format ) => {\n\t\t\t\t\t\taccumulator.push( format, multilineFormat );\n\t\t\t\t\t\treturn accumulator;\n\t\t\t\t\t},\n\t\t\t\t\t[ multilineFormat ]\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tcharacterFormats = [\n\t\t\t\t\t...lastSeparatorFormats,\n\t\t\t\t\t...( characterFormats || [] ),\n\t\t\t\t];\n\t\t\t}\n\t\t}\n\n\t\tlet pointer = getLastChild( tree );\n\n\t\tif ( shouldInsertPadding && character === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tappend( getParent( node ), ZWNBSP );\n\t\t}\n\n\t\t// Set selection for the start of line.\n\t\tif ( lastCharacter === LINE_SEPARATOR ) {\n\t\t\tlet node = pointer;\n\n\t\t\twhile ( ! isText( node ) ) {\n\t\t\t\tnode = getLastChild( node );\n\t\t\t}\n\n\t\t\tif ( onStartIndex && start === i ) {\n\t\t\t\tonStartIndex( tree, node );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === i ) {\n\t\t\t\tonEndIndex( tree, node );\n\t\t\t}\n\t\t}\n\n\t\tif ( characterFormats ) {\n\t\t\tcharacterFormats.forEach( ( format, formatIndex ) => {\n\t\t\t\tif (\n\t\t\t\t\tpointer &&\n\t\t\t\t\tlastCharacterFormats &&\n\t\t\t\t\t// Reuse the last element if all formats remain the same.\n\t\t\t\t\tisEqualUntil(\n\t\t\t\t\t\tcharacterFormats,\n\t\t\t\t\t\tlastCharacterFormats,\n\t\t\t\t\t\tformatIndex\n\t\t\t\t\t) &&\n\t\t\t\t\t// Do not reuse the last element if the character is a\n\t\t\t\t\t// line separator.\n\t\t\t\t\t( character !== LINE_SEPARATOR ||\n\t\t\t\t\t\tcharacterFormats.length - 1 !== formatIndex )\n\t\t\t\t) {\n\t\t\t\t\tpointer = getLastChild( pointer );\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst { type, attributes, unregisteredAttributes } = format;\n\n\t\t\t\tconst boundaryClass =\n\t\t\t\t\tisEditableTree &&\n\t\t\t\t\tcharacter !== LINE_SEPARATOR &&\n\t\t\t\t\tformat === deepestActiveFormat;\n\n\t\t\t\tconst parent = getParent( pointer );\n\t\t\t\tconst newNode = append(\n\t\t\t\t\tparent,\n\t\t\t\t\tfromFormat( {\n\t\t\t\t\t\ttype,\n\t\t\t\t\t\tattributes,\n\t\t\t\t\t\tunregisteredAttributes,\n\t\t\t\t\t\tboundaryClass,\n\t\t\t\t\t} )\n\t\t\t\t);\n\n\t\t\t\tif ( isText( pointer ) && getText( pointer ).length === 0 ) {\n\t\t\t\t\tremove( pointer );\n\t\t\t\t}\n\n\t\t\t\tpointer = append( newNode, '' );\n\t\t\t} );\n\t\t}\n\n\t\t// No need for further processing if the character is a line separator.\n\t\tif ( character === LINE_SEPARATOR ) {\n\t\t\tlastCharacterFormats = characterFormats;\n\t\t\tlastCharacter = character;\n\t\t\tcontinue;\n\t\t}\n\n\t\t// If there is selection at 0, handle it before characters are inserted.\n\t\tif ( i === 0 ) {\n\t\t\tif ( onStartIndex && start === 0 ) {\n\t\t\t\tonStartIndex( tree, pointer );\n\t\t\t}\n\n\t\t\tif ( onEndIndex && end === 0 ) {\n\t\t\t\tonEndIndex( tree, pointer );\n\t\t\t}\n\t\t}\n\n\t\tif ( character === OBJECT_REPLACEMENT_CHARACTER ) {\n\t\t\tpointer = append(\n\t\t\t\tgetParent( pointer ),\n\t\t\t\tfromFormat( {\n\t\t\t\t\t...replacements[ i ],\n\t\t\t\t\tobject: true,\n\t\t\t\t} )\n\t\t\t);\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! preserveWhiteSpace && character === '\\n' ) {\n\t\t\tpointer = append( getParent( pointer ), {\n\t\t\t\ttype: 'br',\n\t\t\t\tattributes: isEditableTree\n\t\t\t\t\t? {\n\t\t\t\t\t\t\t'data-rich-text-line-break': 'true',\n\t\t\t\t\t  }\n\t\t\t\t\t: undefined,\n\t\t\t\tobject: true,\n\t\t\t} );\n\t\t\t// Ensure pointer is text node.\n\t\t\tpointer = append( getParent( pointer ), '' );\n\t\t} else if ( ! isText( pointer ) ) {\n\t\t\tpointer = append( getParent( pointer ), character );\n\t\t} else {\n\t\t\tappendText( pointer, character );\n\t\t}\n\n\t\tif ( onStartIndex && start === i + 1 ) {\n\t\t\tonStartIndex( tree, pointer );\n\t\t}\n\n\t\tif ( onEndIndex && end === i + 1 ) {\n\t\t\tonEndIndex( tree, pointer );\n\t\t}\n\n\t\tif ( shouldInsertPadding && i === text.length ) {\n\t\t\tappend( getParent( pointer ), ZWNBSP );\n\n\t\t\tif ( placeholder && text.length === 0 ) {\n\t\t\t\tappend( getParent( pointer ), {\n\t\t\t\t\ttype: 'span',\n\t\t\t\t\tattributes: {\n\t\t\t\t\t\t'data-rich-text-placeholder': placeholder,\n\t\t\t\t\t\t// Necessary to prevent the placeholder from catching\n\t\t\t\t\t\t// selection. The placeholder is also not editable after\n\t\t\t\t\t\t// all.\n\t\t\t\t\t\tcontenteditable: 'false',\n\t\t\t\t\t},\n\t\t\t\t} );\n\t\t\t}\n\t\t}\n\n\t\tlastCharacterFormats = characterFormats;\n\t\tlastCharacter = character;\n\t}\n\n\treturn tree;\n}\n","/**\n * Internal dependencies\n */\n\nimport { getActiveFormat } from './get-active-format';\nimport { removeFormat } from './remove-format';\nimport { applyFormat } from './apply-format';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n/** @typedef {import('./create').RichTextFormat} RichTextFormat */\n\n/**\n * Toggles a format object to a Rich Text value at the current selection.\n *\n * @param {RichTextValue}  value  Value to modify.\n * @param {RichTextFormat} format Format to apply or remove.\n *\n * @return {RichTextValue} A new value with the format applied or removed.\n */\nexport function toggleFormat( value, format ) {\n\tif ( getActiveFormat( value, format.type ) ) {\n\t\treturn removeFormat( value, format.type );\n\t}\n\n\treturn applyFormat( value, format );\n}\n","/**\n * WordPress dependencies\n */\nimport { select, dispatch } from '@wordpress/data';\n\n/** @typedef {import('./register-format-type').RichTextFormatType} RichTextFormatType */\n\n/**\n * Unregisters a format.\n *\n * @param {string} name Format name.\n *\n * @return {RichTextFormatType|undefined} The previous format value, if it has\n *                                        been successfully unregistered;\n *                                        otherwise `undefined`.\n */\nexport function unregisterFormatType( name ) {\n\tconst oldFormat = select( 'core/rich-text' ).getFormatType( name );\n\n\tif ( ! oldFormat ) {\n\t\twindow.console.error( `Format ${ name } is not registered.` );\n\t\treturn;\n\t}\n\n\tdispatch( 'core/rich-text' ).removeFormatTypes( name );\n\n\treturn oldFormat;\n}\n","/**\n * Internal dependencies\n */\n\nimport { isFormatEqual } from './is-format-equal';\n\n/** @typedef {import('./create').RichTextValue} RichTextValue */\n\n/**\n * Efficiently updates all the formats from `start` (including) until `end`\n * (excluding) with the active formats. Mutates `value`.\n *\n * @param  {Object}        $1         Named paramentes.\n * @param  {RichTextValue} $1.value   Value te update.\n * @param  {number}        $1.start   Index to update from.\n * @param  {number}        $1.end     Index to update until.\n * @param  {Array}         $1.formats Replacement formats.\n *\n * @return {RichTextValue} Mutated value.\n */\nexport function updateFormats( { value, start, end, formats } ) {\n\tconst formatsBefore = value.formats[ start - 1 ] || [];\n\tconst formatsAfter = value.formats[ end ] || [];\n\n\t// First, fix the references. If any format right before or after are\n\t// equal, the replacement format should use the same reference.\n\tvalue.activeFormats = formats.map( ( format, index ) => {\n\t\tif ( formatsBefore[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsBefore[ index ] ) ) {\n\t\t\t\treturn formatsBefore[ index ];\n\t\t\t}\n\t\t} else if ( formatsAfter[ index ] ) {\n\t\t\tif ( isFormatEqual( format, formatsAfter[ index ] ) ) {\n\t\t\t\treturn formatsAfter[ index ];\n\t\t\t}\n\t\t}\n\n\t\treturn format;\n\t} );\n\n\twhile ( --end >= start ) {\n\t\tif ( value.activeFormats.length > 0 ) {\n\t\t\tvalue.formats[ end ] = value.activeFormats;\n\t\t} else {\n\t\t\tdelete value.formats[ end ];\n\t\t}\n\t}\n\n\treturn value;\n}\n","'use strict';\n\nvar LEAF_KEY, hasWeakMap;\n\n/**\n * Arbitrary value used as key for referencing cache object in WeakMap tree.\n *\n * @type {Object}\n */\nLEAF_KEY = {};\n\n/**\n * Whether environment supports WeakMap.\n *\n * @type {boolean}\n */\nhasWeakMap = typeof WeakMap !== 'undefined';\n\n/**\n * Returns the first argument as the sole entry in an array.\n *\n * @param {*} value Value to return.\n *\n * @return {Array} Value returned as entry in array.\n */\nfunction arrayOf( value ) {\n\treturn [ value ];\n}\n\n/**\n * Returns true if the value passed is object-like, or false otherwise. A value\n * is object-like if it can support property assignment, e.g. object or array.\n *\n * @param {*} value Value to test.\n *\n * @return {boolean} Whether value is object-like.\n */\nfunction isObjectLike( value ) {\n\treturn !! value && 'object' === typeof value;\n}\n\n/**\n * Creates and returns a new cache object.\n *\n * @return {Object} Cache object.\n */\nfunction createCache() {\n\tvar cache = {\n\t\tclear: function() {\n\t\t\tcache.head = null;\n\t\t},\n\t};\n\n\treturn cache;\n}\n\n/**\n * Returns true if entries within the two arrays are strictly equal by\n * reference from a starting index.\n *\n * @param {Array}  a         First array.\n * @param {Array}  b         Second array.\n * @param {number} fromIndex Index from which to start comparison.\n *\n * @return {boolean} Whether arrays are shallowly equal.\n */\nfunction isShallowEqual( a, b, fromIndex ) {\n\tvar i;\n\n\tif ( a.length !== b.length ) {\n\t\treturn false;\n\t}\n\n\tfor ( i = fromIndex; i < a.length; i++ ) {\n\t\tif ( a[ i ] !== b[ i ] ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\n/**\n * Returns a memoized selector function. The getDependants function argument is\n * called before the memoized selector and is expected to return an immutable\n * reference or array of references on which the selector depends for computing\n * its own return value. The memoize cache is preserved only as long as those\n * dependant references remain the same. If getDependants returns a different\n * reference(s), the cache is cleared and the selector value regenerated.\n *\n * @param {Function} selector      Selector function.\n * @param {Function} getDependants Dependant getter returning an immutable\n *                                 reference or array of reference used in\n *                                 cache bust consideration.\n *\n * @return {Function} Memoized selector.\n */\nexport default function( selector, getDependants ) {\n\tvar rootCache, getCache;\n\n\t// Use object source as dependant if getter not provided\n\tif ( ! getDependants ) {\n\t\tgetDependants = arrayOf;\n\t}\n\n\t/**\n\t * Returns the root cache. If WeakMap is supported, this is assigned to the\n\t * root WeakMap cache set, otherwise it is a shared instance of the default\n\t * cache object.\n\t *\n\t * @return {(WeakMap|Object)} Root cache object.\n\t */\n\tfunction getRootCache() {\n\t\treturn rootCache;\n\t}\n\n\t/**\n\t * Returns the cache for a given dependants array. When possible, a WeakMap\n\t * will be used to create a unique cache for each set of dependants. This\n\t * is feasible due to the nature of WeakMap in allowing garbage collection\n\t * to occur on entries where the key object is no longer referenced. Since\n\t * WeakMap requires the key to be an object, this is only possible when the\n\t * dependant is object-like. The root cache is created as a hierarchy where\n\t * each top-level key is the first entry in a dependants set, the value a\n\t * WeakMap where each key is the next dependant, and so on. This continues\n\t * so long as the dependants are object-like. If no dependants are object-\n\t * like, then the cache is shared across all invocations.\n\t *\n\t * @see isObjectLike\n\t *\n\t * @param {Array} dependants Selector dependants.\n\t *\n\t * @return {Object} Cache object.\n\t */\n\tfunction getWeakMapCache( dependants ) {\n\t\tvar caches = rootCache,\n\t\t\tisUniqueByDependants = true,\n\t\t\ti, dependant, map, cache;\n\n\t\tfor ( i = 0; i < dependants.length; i++ ) {\n\t\t\tdependant = dependants[ i ];\n\n\t\t\t// Can only compose WeakMap from object-like key.\n\t\t\tif ( ! isObjectLike( dependant ) ) {\n\t\t\t\tisUniqueByDependants = false;\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// Does current segment of cache already have a WeakMap?\n\t\t\tif ( caches.has( dependant ) ) {\n\t\t\t\t// Traverse into nested WeakMap.\n\t\t\t\tcaches = caches.get( dependant );\n\t\t\t} else {\n\t\t\t\t// Create, set, and traverse into a new one.\n\t\t\t\tmap = new WeakMap();\n\t\t\t\tcaches.set( dependant, map );\n\t\t\t\tcaches = map;\n\t\t\t}\n\t\t}\n\n\t\t// We use an arbitrary (but consistent) object as key for the last item\n\t\t// in the WeakMap to serve as our running cache.\n\t\tif ( ! caches.has( LEAF_KEY ) ) {\n\t\t\tcache = createCache();\n\t\t\tcache.isUniqueByDependants = isUniqueByDependants;\n\t\t\tcaches.set( LEAF_KEY, cache );\n\t\t}\n\n\t\treturn caches.get( LEAF_KEY );\n\t}\n\n\t// Assign cache handler by availability of WeakMap\n\tgetCache = hasWeakMap ? getWeakMapCache : getRootCache;\n\n\t/**\n\t * Resets root memoization cache.\n\t */\n\tfunction clear() {\n\t\trootCache = hasWeakMap ? new WeakMap() : createCache();\n\t}\n\n\t// eslint-disable-next-line jsdoc/check-param-names\n\t/**\n\t * The augmented selector call, considering first whether dependants have\n\t * changed before passing it to underlying memoize function.\n\t *\n\t * @param {Object} source    Source object for derivation.\n\t * @param {...*}   extraArgs Additional arguments to pass to selector.\n\t *\n\t * @return {*} Selector result.\n\t */\n\tfunction callSelector( /* source, ...extraArgs */ ) {\n\t\tvar len = arguments.length,\n\t\t\tcache, node, i, args, dependants;\n\n\t\t// Create copy of arguments (avoid leaking deoptimization).\n\t\targs = new Array( len );\n\t\tfor ( i = 0; i < len; i++ ) {\n\t\t\targs[ i ] = arguments[ i ];\n\t\t}\n\n\t\tdependants = getDependants.apply( null, args );\n\t\tcache = getCache( dependants );\n\n\t\t// If not guaranteed uniqueness by dependants (primitive type or lack\n\t\t// of WeakMap support), shallow compare against last dependants and, if\n\t\t// references have changed, destroy cache to recalculate result.\n\t\tif ( ! cache.isUniqueByDependants ) {\n\t\t\tif ( cache.lastDependants && ! isShallowEqual( dependants, cache.lastDependants, 0 ) ) {\n\t\t\t\tcache.clear();\n\t\t\t}\n\n\t\t\tcache.lastDependants = dependants;\n\t\t}\n\n\t\tnode = cache.head;\n\t\twhile ( node ) {\n\t\t\t// Check whether node arguments match arguments\n\t\t\tif ( ! isShallowEqual( node.args, args, 1 ) ) {\n\t\t\t\tnode = node.next;\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\t// At this point we can assume we've found a match\n\n\t\t\t// Surface matched node to head if not already\n\t\t\tif ( node !== cache.head ) {\n\t\t\t\t// Adjust siblings to point to each other.\n\t\t\t\tnode.prev.next = node.next;\n\t\t\t\tif ( node.next ) {\n\t\t\t\t\tnode.next.prev = node.prev;\n\t\t\t\t}\n\n\t\t\t\tnode.next = cache.head;\n\t\t\t\tnode.prev = null;\n\t\t\t\tcache.head.prev = node;\n\t\t\t\tcache.head = node;\n\t\t\t}\n\n\t\t\t// Return immediately\n\t\t\treturn node.val;\n\t\t}\n\n\t\t// No cached value found. Continue to insertion phase:\n\n\t\tnode = {\n\t\t\t// Generate the result from original function\n\t\t\tval: selector.apply( null, args ),\n\t\t};\n\n\t\t// Avoid including the source object in the cache.\n\t\targs[ 0 ] = null;\n\t\tnode.args = args;\n\n\t\t// Don't need to check whether node is already head, since it would\n\t\t// have been returned above already if it was\n\n\t\t// Shift existing head down list\n\t\tif ( cache.head ) {\n\t\t\tcache.head.prev = node;\n\t\t\tnode.next = cache.head;\n\t\t}\n\n\t\tcache.head = node;\n\n\t\treturn node.val;\n\t}\n\n\tcallSelector.getDependants = getDependants;\n\tcallSelector.clear = clear;\n\tclear();\n\n\treturn callSelector;\n}\n","(function() { module.exports = this[\"wp\"][\"data\"]; }());","(function() { module.exports = this[\"wp\"][\"deprecated\"]; }());","(function() { module.exports = this[\"wp\"][\"element\"]; }());","(function() { module.exports = this[\"wp\"][\"escapeHtml\"]; }());","(function() { module.exports = this[\"wp\"][\"keycodes\"]; }());","(function() { module.exports = this[\"lodash\"]; }());"],"sourceRoot":""}